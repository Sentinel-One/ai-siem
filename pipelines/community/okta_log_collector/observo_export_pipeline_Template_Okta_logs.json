{
    "pipeline": {
        "id": "0",
        "siteId": "16",
        "name": "Pipeline Template_Okta_Log_Collector",
        "description": "",
        "status": "DEFAULT",
        "createdAt": "2025-11-19T21:17:07.617051Z",
        "updatedAt": "2025-11-19T21:17:10.816277Z",
        "deletedAt": null,
        "createdBy": "",
        "updatedBy": "",
        "deployedGraphVersion": 0,
        "pendingGraphVersion": 0,
        "latestGraphVersion": 0,
        "sourceId": "0",
        "pipelineType": "PIPELINE_TYPE_USER",
        "pendingAction": "NOP",
        "analytics": []
    },
    "pipelineGraph": {
        "version": 1,
        "pipelineId": "0",
        "edges": {
            "100000000000000024": {
                "nodeIds": [
                    "300000000000000214"
                ]
            },
            "300000000000000214": {
                "nodeIds": [
                    "200000000000000044"
                ]
            }
        },
        "created": "2025-11-19T21:17:10.816277Z",
        "createdBy": "",
        "metaInfo": {
            "omissions": [
                {
                    "omitted": {
                        "100000000000000024": {
                            "nodeIds": [
                                "300000000000000215"
                            ]
                        },
                        "300000000000000215": {
                            "nodeIds": [
                                "300000000000000214"
                            ]
                        }
                    },
                    "patch": {
                        "100000000000000024": {
                            "nodeIds": [
                                "300000000000000214"
                            ]
                        }
                    }
                },
                {
                    "omitted": {
                        "300000000000000214": {
                            "nodeIds": [
                                "300000000000000216"
                            ]
                        },
                        "300000000000000216": {
                            "nodeIds": [
                                "200000000000000044"
                            ]
                        }
                    },
                    "patch": {
                        "300000000000000214": {
                            "nodeIds": [
                                "200000000000000044"
                            ]
                        }
                    }
                }
            ]
        }
    },
    "source": {
        "id": "100000000000000024",
        "siteId": "16",
        "templateId": "31",
        "templateVersion": "1",
        "templateName": "Okta Logs Collector",
        "name": "Source Template_Okta_Log_Collector",
        "description": "This is the Default approach to Send data into your SentinelOne Console",
        "config": {
            "auth.header": "Authorization",
            "auth.prefix": "SSWS ",
            "auth.strategy": "bearer",
            "auth.token": "00cg6uyHDsAljarCKz6teJq9veEx3QAccVdS7zdfGJ",
            "domain": "sentinelone-preview.oktapreview.com",
            "initial_since": "2023-01-01T00:00:00.000Z",
            "max_page_calls": 10,
            "retry.backoff_scaling_factor": 2,
            "retry.initial_backoff_secs": 1,
            "retry.max_backoff_secs": 5,
            "retry.max_retries": 4,
            "scale.completion_queue": 10,
            "scale.event_batch_queue": 10,
            "scale.fetch_req_queue": 1000,
            "scale.fetch_res_queue": 10,
            "scale.fetchers": 8,
            "scale.runtimes": 2,
            "script": "local json = require('json')\nlocal log = require('log')\n\nfunction start(config)\n    -- Get checkpoint for next URL or build initial URL\n    local next_url = get_chkpt(\"next_url\")\n    local since_time = get_chkpt(\"initial_since\")\n    \n    -- Trigger fetch for Okta system logs with initial page calls limit\n    max_page_calls = tonumber(config[\"max_page_calls\"]) or 10\n    fetch_system_logs(config, since_time, next_url, max_page_calls)\nend\n\nfunction fetch_system_logs(config, since_time, next_url, page_calls_left)\n    local url\n    \n    if next_url and next_url ~= \"\" then\n        -- Use saved next_url from checkpoint\n        url = next_url\n    else\n        -- Build initial URL with timestamp and higher limit\n        url = \"https://\" .. config[\"domain\"] .. \"/api/v1/logs?since=\" .. since_time .. \"&limit=1000&sortOrder=ASCENDING\"\n    end\n    \n    local params = {\n        url = url,\n        method = \"GET\",\n        headers = {\n            [\"Accept\"] = \"application/json\",\n            [\"Content-Type\"] = \"application/json\"\n        }\n    }\n    \n    fetch {\n        params = params,\n        fn = \"process_system_logs\",\n        retry = true,\n        context = {\n            request_time = os.time(),\n            since_time_used = since_time,\n            page_calls_left = page_calls_left\n        }\n    }\nend\n\nfunction no_nulls(d, rn)\n    if type(d) == \"table\" then\n        for k, v in pairs(d) do\n              if type(v) == \"userdata\" then\n                  -- Handle all userdata types (null values from JSON)\n                  -- Both userdata: (nil) and userdata: 0x0 are null values\n                  d[k] = rn\n            elseif type(v) == \"table\" then\n                no_nulls(v, rn)\n            end\n        end\n    end\nend\n\nfunction process_system_logs(config, response, context)\n    -- Decrement page calls left counter\n    local page_calls_left = context.page_calls_left - 1\n    \n    if response.status == 200 then\n        local data = json.decode(response.body)\n        no_nulls(data, nil)\n        \n        if data and type(data) == \"table\" then\n            \n            -- Emit each log entry\n            for _, entry in ipairs(data) do\n                entry._okta_event_type = \"systemLog\"\n                emit{log = entry}\n            end\n            \n            -- Get the timestamp of the last event for checkpointing\n            if #data > 0 then\n                local last_event = data[#data]\n                if last_event.published then\n                    set_chkpt(\"initial_since\", last_event.published)\n                end\n            end\n            \n            -- Check for next page using Link header and remaining page calls\n            if response.headers and response.headers[\"link\"] then\n                local next_url = extract_next_url(response.headers[\"link\"])\n                log.debug(\"Next url = \" .. next_url)\n                set_chkpt(\"next_url\", next_url)\n                \n                -- Check if we have any page calls left\n                if next_url and #data > 0 and page_calls_left > 0 then\n                    log.debug(\"Pages calls left: \" .. page_calls_left)\n                    fetch_system_logs(config, context.since_time_used, next_url, page_calls_left)\n                else\n                    if page_calls_left <= 0 then\n                        log.debug(\"Reached maximum page call limit\")\n                    elseif #data == 0 then\n                        log.debug(\"Empty response, stopping pagination\")\n                    else\n                        log.debug(\"No next URL, stopping pagination\")\n                    end\n                end\n            else\n                log.debug(\"No Link header or next URL, stopping pagination\")\n                set_chkpt(\"next_url\", \"\")\n            end\n        else\n            log.warn(\"No system log data found in response\")\n        end\n        \n    elseif response.status == 401 then\n        log.error(\"Authentication failed - check OKTA_API_TOKEN\")\n    elseif response.status == 429 then\n        log.warn(\"Rate limit exceeded - will retry in next iteration\")\n    elseif response.status == 400 then\n        log.error(\"Bad request - check API parameters\")\n    else\n        log.error(\"Failed to fetch Okta system logs. Status=\" .. response.status)\n    end\nend\n\nfunction extract_next_url(link_header)\n    -- Parse Link header to find next page URL\n    -- Format: <https://...>; rel=\"next\"\n    local next_url = string.match(link_header, '<([^>]+)>%s*;%s*rel=\"next\"')\n    return next_url\nend",
            "start_routine": "start",
            "tls.enabled": false,
            "trigger.interval_secs": 120
        },
        "status": "NS_ACTIVE",
        "created": "2025-11-19T21:15:37.135665Z",
        "updated": "2025-11-19T21:21:49.437388Z",
        "createdBy": "",
        "updatedBy": "",
        "type": "SCOL_OKTA",
        "origin": "NODE_ORIGIN_USER",
        "archivalInfo": null,
        "logFormat": "LOG_FORMAT_UNSPECIFIED",
        "preprocessorConfig": null,
        "port": 0,
        "pushBased": false,
        "pushSourceAddress": "",
        "k8sInternalSvcUrl": "",
        "siteFilenames": [],
        "sourceConfigs": [
            {
                "id": "0",
                "sourceId": "0",
                "templateId": "30",
                "templateName": "JSON",
                "category": "PARSER",
                "config": {
                    "config_groups": [
                        {
                            "_name": "General Configuration",
                            "bypassed": false,
                            "filterEnabled": false
                        },
                        {
                            "_name": "jsonParser",
                            "enabled": true,
                            "jsons": [
                                {
                                    "explode_array_events": true,
                                    "merge_with_exploded": true,
                                    "old_field": "message"
                                }
                            ]
                        }
                    ]
                },
                "position": 0,
                "templateVersion": "1"
            },
            {
                "id": "0",
                "sourceId": "0",
                "templateId": "46",
                "templateName": "SentimentAnalyzer",
                "category": "PATTERN_EXTRACTOR",
                "config": {
                    "config_groups": [
                        {
                            "_name": "Config",
                            "enabled": false,
                            "keyNameForExtractedSentiment": "sentiment",
                            "logLocations": [],
                            "negativeSentimentRegexes": [
                                "time[\\s_-]*out",
                                "timed[\\s_-]*out",
                                "(?i)alert ([=\\s\\*]+|$)",
                                "(?i)bad[\\s_-]*gateway",
                                "(?i)bad[\\s_-]*request",
                                "(?i)(^| [=\\s\\*]+)bad([=\\s\\*]+|$)",
                                "(?i)does[\\s_-]*not[\\s_-]*exist",
                                "(?i)[=\\s\\*]+eof([=\\s\\*]+|$)",
                                "(?i)exception([=\\s\\*]+|$)",
                                "(?i)fail([=\\s\\*]+|$)",
                                "(?i)failed([=\\s\\*]+|$)",
                                "(?i)failure([=\\s\\*]+|$)",
                                "(?i)(^|[=\\s\\*]+)fault([=\\s\\*]+|$)",
                                "(?i)(^| [=\\s\\*]+)feof([=\\s\\*]+|$)",
                                "(?i)not[\\s_-]*acceptable",
                                "(?i)not[\\s_-]*allowed",
                                "(?i)not[\\s_-]*found",
                                "(?i)not[\\s_-]*ok",
                                "(?i)(^| [=\\s\\*]+)oom([=\\s\\*]+|$)",
                                "(?i)too[\\s_-]*many"
                            ],
                            "negativeSentimentWords": [
                                "abnormal",
                                "abort",
                                "broken",
                                "canceled",
                                "caught",
                                "critical",
                                "denied",
                                "emergency",
                                "error",
                                "exception",
                                "fatal",
                                "incomplete",
                                "insufficient",
                                "interrupt",
                                "killed",
                                "killing",
                                "malformed",
                                "mismatch",
                                "outofmemory",
                                "panic",
                                "segfault",
                                "terminate",
                                "timeout",
                                "unable",
                                "unauthorized",
                                "undefined",
                                "unexpected",
                                "unprocessable",
                                "unstable",
                                "unhandled",
                                "unsuccessful",
                                "unusable",
                                "violation",
                                "rejection",
                                "rejected"
                            ],
                            "useLogPath": true
                        }
                    ]
                },
                "position": 2,
                "templateVersion": "1"
            },
            {
                "id": "0",
                "sourceId": "0",
                "templateId": "71",
                "templateName": "GeneratorVersion",
                "category": "INTERNAL",
                "config": {
                    "generator_version": "v2"
                },
                "position": 0,
                "templateVersion": "0"
            },
            {
                "id": "0",
                "sourceId": "0",
                "templateId": "65",
                "templateName": "PatternExtractorPostProcessor",
                "category": "PATTERN_EXTRACTOR",
                "config": {
                    "config_groups": [
                        {
                            "_name": "Pattern Extractor Configs",
                            "clusterTagNames": [],
                            "truncate": false
                        }
                    ]
                },
                "position": 1,
                "templateVersion": "1"
            }
        ],
        "userVisible": true,
        "usageType": "USER"
    },
    "destinations": [
        {
            "id": "200000000000000044",
            "siteId": "16",
            "templateId": "25",
            "templateVersion": "0",
            "templateName": "SentinelOne AI SIEM",
            "name": "Sink Template_SentinelOne AI SIEM",
            "description": "This is the Default approach to Send data into your SentinelOne Console",
            "config": {
                "acknowledgements.enabled": false,
                "acknowledgements.indexer_acknowledgements_enabled": true,
                "acknowledgements.query_interval": 10,
                "acknowledgements.retry_limit": 30,
                "batch.timeout_secs": 1,
                "compression": "none",
                "default_token": "********",
                "encoding.codec": "json",
                "encoding.json.pretty": false,
                "encoding.metric_tag_values": "single",
                "endpoint": "https://ingest.us1.sentinelone.net",
                "endpoint_target": "event",
                "host_key": "host",
                "path": "/services/collector/event?isParsed=true",
                "request.concurrency": "adaptive",
                "request.headers": {},
                "request.rate_limit_duration_secs": 1,
                "request.retry_initial_backoff_secs": 1,
                "request.retry_max_duration_secs": 3600,
                "request.timeout_secs": 60,
                "timestamp_key": "timestamp",
                "tls.verify_certificate": false,
                "tls.verify_hostname": false
            },
            "status": "NS_ACTIVE",
            "sourceId": "0",
            "created": "2025-11-16T22:17:36.683043Z",
            "updated": "2025-11-20T17:19:18.696952Z",
            "createdBy": "",
            "updatedBy": "",
            "type": "SPLUNK_HEC_LOGS",
            "origin": "NODE_ORIGIN_USER",
            "usageType": "USER",
            "siteFilenames": [],
            "userVisible": true
        }
    ],
    "transforms": [
        {
            "id": "300000000000000214",
            "siteId": "16",
            "templateId": "60",
            "templateVersion": "2",
            "name": "Transform Template_Okta_Log_Collector",
            "description": "",
            "pipelineId": "0",
            "config": {
                "config_groups": [
                    {
                        "_name": "General Configuration",
                        "bypassed": false,
                        "filterEnabled": false
                    },
                    {
                        "_name": "ocsf",
                        "enabled": true,
                        "parallelism": 1,
                        "script": "\n-- Lua implementation for Okta OCSF 1.0.0 schema\n\n-- Helper function to safely access nested dictionary keys\nfunction safelyAccessNestedDictKeys(keys, dictObject)\n    local current = dictObject\n    for _, key in ipairs(keys) do\n        if current and type(current) == \"table\" then\n            current = current[key]\n        else\n            return nil\n        end\n    end\n    return current\nend\n\n-- Helper function to split string by delimiter\nfunction split(str, delimiter)\n    local result = {}\n    -- Escape special regex characters in delimiter\n    local escapedDelimiter = delimiter:gsub(\"[%.%+%*%?%^%$%(%)%[%]%%]\", \"%%%1\")\n    local pattern = \"([^\" .. escapedDelimiter .. \"]+)\"\n\n    for token in str:gmatch(pattern) do\n        table.insert(result, token)\n    end\n\n    -- Handle empty string case\n    if #result == 0 and #str > 0 then\n        table.insert(result, str)\n    end\n\n    return result\nend\n\n-- Helper function to convert timestamp to milliseconds\nfunction convertToMilliseconds(timestamp)\n    if not timestamp or timestamp == \"\" then\n        return nil\n    end\n    \n    -- Parse ISO 8601 timestamp (e.g., \"2023-04-24T04:55:30.535Z\")\n    local year, month, day, hour, min, sec, ms = timestamp:match(\"(%d%d%d%d)-(%d%d)-(%d%d)T(%d%d):(%d%d):(%d%d)%.(%d%d%d)Z\")\n    \n    if year and month and day and hour and min and sec and ms then\n        -- Convert to milliseconds since epoch\n        local time = os.time({\n            year = tonumber(year),\n            month = tonumber(month),\n            day = tonumber(day),\n            hour = tonumber(hour),\n            min = tonumber(min),\n            sec = tonumber(sec)\n        })\n        return (time * 1000) + tonumber(ms)\n    end\n    \n    return nil\nend\n\n-- Ordered JSON encoding helpers (FIELD_ORDERS like Cisco Duo)\nlocal FIELD_ORDERS = {\n    root = {\n        \"actor\", \"client\", \"device\", \"authenticationContext\", \"displayMessage\",\n        \"eventType\", \"outcome\", \"published\", \"securityContext\", \"severity\",\n        \"debugContext\", \"legacyEventType\", \"transaction\", \"uuid\", \"version\",\n        \"request\", \"target\"\n    },\n    actor = {\"id\", \"type\", \"alternateId\", \"displayName\", \"detailEntry\"},\n    client = {\"userAgent\", \"zone\", \"device\", \"id\", \"ipAddress\", \"geographicalContext\"},\n    userAgent = {\"rawUserAgent\", \"os\", \"browser\"},\n    geographicalContext = {\"city\", \"state\", \"country\", \"postalCode\", \"geolocation\"},\n    geolocation = {\"lat\", \"lon\"},\n    authenticationContext = {\n        \"authenticationProvider\", \"credentialProvider\", \"credentialType\", \"issuer\",\n        \"interface\", \"authenticationStep\", \"externalSessionId\"\n    },\n    issuer = {\"id\", \"type\"},\n    outcome = {\"result\", \"reason\"},\n    securityContext = {\"asNumber\", \"asOrg\", \"isp\", \"domain\", \"isProxy\"},\n    debugContext = {\"debugData\"},\n    debugData = {\"initiationType\", \"redirectUri\", \"requestId\", \"dtHash\", \"signOnMode\", \"requestUri\", \"threatSuspected\", \"url\", \"risk\", \"deviceFingerprint\", \"authnRequestId\", \"behaviors\", \"warningPercent\", \"rateLimitBucketUuid\", \"rateLimitSecondsToReset\", \"threshold\", \"timeSpan\", \"rateLimitScopeType\", \"userId\", \"timeUnit\"},\n    transaction = {\"type\", \"id\", \"detail\"},\n    request = {\"ipChain\"},\n    ipChain = {\"ip\", \"geographicalContext\", \"version\", \"source\"},\n    dst_endpoint = {\"uid\", \"svc_name\"},\n    user = {\"id\", \"email_addr\", \"name\"},\n    target = {\"id\", \"type\", \"alternateId\", \"displayName\", \"detailEntry\"}\n}\n\nlocal function encodeWithFieldOrder(obj, fieldOrder)\n    local items = {}\n    -- Phase 1: predefined order\n    for _, fieldName in ipairs(fieldOrder) do\n        if obj[fieldName] ~= nil then\n            local valueStr = encodeJson(obj[fieldName], fieldName)\n            if valueStr ~= nil then\n                table.insert(items, '\"' .. fieldName .. '\": ' .. valueStr)\n            end\n        end\n    end\n    -- Phase 2: remaining fields\n    for k, v in pairs(obj) do\n        local found = false\n        for _, fieldName in ipairs(fieldOrder) do\n            if k == fieldName then found = true; break end\n        end\n        if not found then\n            local keyStr = type(k) == \"string\" and k or tostring(k)\n            local valueStr = encodeJson(v, k)\n            if valueStr ~= nil then\n                table.insert(items, '\"' .. keyStr:gsub('\"', '\\\\\"') .. '\": ' .. valueStr)\n            end\n        end\n    end\n    -- If no items were added, return nil to skip empty objects\n    if #items == 0 then\n        return nil\n    end\n    return \"{\" .. table.concat(items, \", \") .. \"}\"\nend\n\n-- JSON encoding function (from AWS CloudTrail) - Compact single-line output\nfunction encodeJson(obj, key)\n    if obj == nil or obj == \"NULL_PLACEHOLDER\" or obj == \"\" then\n        return nil  -- Skip null and empty fields entirely\n    elseif type(obj) == \"boolean\" then\n        return tostring(obj)\n    elseif type(obj) == \"number\" then\n        return tostring(obj)\n    elseif type(obj) == \"string\" then\n        return '\"' .. obj:gsub('\"', '\\\\\"') .. '\"'\n    elseif type(obj) == \"table\" then\n        local isArray = true\n        local maxIndex = 0\n        for k, v in pairs(obj) do\n            if type(k) ~= \"number\" then\n                isArray = false\n                break\n            end\n            maxIndex = math.max(maxIndex, k)\n        end\n\n        if isArray then\n            local items = {}\n            for i = 1, maxIndex do\n                local elementKey = key or tostring(i)\n                local encoded = encodeJson(obj[i], elementKey)\n                if encoded ~= nil then\n                    table.insert(items, encoded)\n                end\n            end\n            -- Return nil for empty arrays to skip them entirely\n            if #items == 0 then\n                return nil\n            end\n            return \"[\" .. table.concat(items, \", \") .. \"]\"\n        else\n            -- Check if this is an empty object - if so, return nil to skip it\n            if next(obj) == nil then\n                return nil\n            end\n\n            -- If we have a field order for this object key, use it\n            if key and FIELD_ORDERS[key] then\n                return encodeWithFieldOrder(obj, FIELD_ORDERS[key])\n            end\n            -- If top-level message root, use root order\n            if key == \"root\" and FIELD_ORDERS.root then\n                return encodeWithFieldOrder(obj, FIELD_ORDERS.root)\n            end\n            -- Fallback: unordered (natural) encoding\n            local items = {}\n            for k, v in pairs(obj) do\n                local keyStr = type(k) == \"string\" and k or tostring(k)\n                local valueStr = encodeJson(v, keyStr)\n                -- Only include fields that have non-nil values\n                if valueStr ~= nil then\n                    table.insert(items, '\"' .. keyStr:gsub('\"', '\\\\\"') .. '\": ' .. valueStr)\n                end\n            end\n            -- If no items were added, return nil to skip empty objects\n            if #items == 0 then\n                return nil\n            end\n            return \"{\" .. table.concat(items, \", \") .. \"}\"\n        end\n    else\n        return '\"' .. tostring(obj) .. '\"'\n    end\nend\n\n-- Get default mapping for event type\nfunction getDefaultMapping(eventType)\n    local defaultMapping = {\n        [\"user.session.start\"] = {\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"version\", target = \"api.version\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"session.uid\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.authenticationProvider\", target = \"service.name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"debugContext.debugData.requestId\", target = \"http_request.uid\"},\n            {source = \"debugContext.debugData.origin\", target = \"device.hostname\"},\n            {source = \"debugContext.debugData.risk\", target = \"device.risk_level\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"}\n        },\n        [\"user.authentication.sso\"] = {\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"session.uid\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.authenticationProvider\", target = \"service.name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"debugContext.debugData.requestId\", target = \"http_request.uid\"},\n            {source = \"debugContext.debugData.signOnMode\", target = \"auth_protocol\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"version\", target = \"api.version\"},\n            -- target fields\n            {source = \"dst_endpoint_uid\", target = \"dst_endpoint.uid\"},\n            {source = \"actor_user_uid\", target = \"actor.user.uid\"},\n            {source = \"dst_endpoint_svc_name\", target = \"dst_endpoint.svc_name\"},\n            {source = \"actor_email_addr\", target = \"actor.email_addr\"}\n            --{source = \"actor_user_name\", target = \"user.name\"}\n        },\n        [\"user.lifecycle.activate\"] = {\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.userAgent.browser\", target = \"client.userAgent.browser\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"actor.session.uid\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"version\", target = \"api.version\"}\n            -- target\n            --{source = \"user_id\", target = \"user.id\"}\n            --{source = \"user_email_addr\", target = \"user.email_addr\"}\n            --{source = \"user_name\", target = \"user.name\"}\n        },\n        [\"user.lifecycle.create\"] = {\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"actor.session.uid\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"debugContext.debugData.requestId\", target = \"api.request.uid\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"version\", target = \"api.version\"}\n            -- target\n            --{source = \"user_id\", target = \"user.id\"}\n            --{source = \"user_email_addr\", target = \"user.email_addr\"},\n            --{source = \"user_name\", target = \"user.name\"}\n        },\n        [\"user.lifecycle.deactivate\"] = {\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"actor.session.uid\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"debugContext.debugData.requestId\", target = \"api.request.uid\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"version\", target = \"api.version\"}\n            -- target\n            --{source = \"user_id\", target = \"user.id\"},\n            --{source = \"user_email_addr\", target = \"user.email_addr\"},\n            --{source = \"user_name\", target = \"user.name\"}\n        },\n        [\"policy.evaluate_sign_on\"] = {\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"authenticationContext.authenticationProvider\", target = \"name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"session.uid\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"debugContext.debugData.deviceFingerprint\", target = \"device.uid\"},\n            {source = \"debugContext.debugData.requestId\", target = \"http_request.uid\"},\n            {source = \"debugContext.debugData.risk\", target = \"device.risk_level\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"version\", target = \"api.version\"},\n            -- target fields\n            {source = \"actor.authorization.policy.uid\", target = \"actor.authorization.policy.uid\"},\n            {source = \"actor.authorization.policy.name\", target = \"actor.authorization.policy.name\"},\n            {source = \"actor.authorization.policy.rule.uid\", target = \"actor.authorization.policy.rule.uid\"},\n            {source = \"actor.authorization.policy.rule.name\", target = \"actor.authorization.policy.rule.name\"}\n        },\n        [\"system.org.rate_limit.warning\"] = {\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"version\", target = \"api.version\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"actor.session.uid\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"debugContext.debugData.requestId\", target = \"http_request.uid\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"}\n        },\n        [\"application.user_membership.add\"] = {\n            {source = \"uuid\", target = \"metadata.uid\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"version\", target = \"api.version\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"client.ipAddress\", target = \"src_endpoint.ip\"},\n            {source = \"client.id\", target = \"src_endpoint.uid\"},\n            {source = \"client.geographicalContext.city\", target = \"src_endpoint.location.city\"},\n            {source = \"client.geographicalContext.country\", target = \"src_endpoint.location.country\"},\n            {source = \"client.geographicalContext.geolocation.lat\", target = \"location.coordinates.lat\"},\n            {source = \"client.geographicalContext.geolocation.lon\", target = \"location.coordinates.lon\"},\n            {source = \"client.geographicalContext.postalCode\", target = \"src_endpoint.location.postal_code\"},\n            {source = \"client.geographicalContext.state\", target = \"src_endpoint.location.region\"},\n            {source = \"client.userAgent.rawUserAgent\", target = \"http_request.user_agent\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"authenticationContext.externalSessionId\", target = \"actor.session.uid\"},\n            {source = \"authenticationContext.issuer.id\", target = \"actor.idp.uid\"},\n            {source = \"authenticationContext.issuer.type\", target = \"actor.idp.name\"},\n            {source = \"authenticationContext.credentialProvider\", target = \"actor.invoked_by\"},\n            {source = \"authenticationContext.credentialType\", target = \"actor.user.account.type\"},\n            {source = \"debugContext.debugData.requestUri\", target = \"http_request.url.path\"},\n            {source = \"debugContext.debugData.url\", target = \"http_request.url.query_string\"},\n            {source = \"debugContext.debugData.requestId\", target = \"http_request.uid\"},\n            {source = \"debugContext.debugData.origin\", target = \"device.hostname\"},\n            {source = \"debugContext.debugData.risk\", target = \"device.risk_level\"},\n            {source = \"securityContext.isp\", target = \"src_endpoint.location.isp\"},\n            {source = \"securityContext.domain\", target = \"src_endpoint.location.domain\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            -- target fields\n            {source = \"dst_endpoint_uid\", target = \"dst_endpoint.uid\"},\n            {source = \"dst_endpoint_svc_name\", target = \"dst_endpoint.svc_name\"},\n            {source = \"actor_user_uid\", target = \"actor.user.uid\"},\n            {source = \"actor_email_addr\", target = \"actor.email_addr\"}\n            --{source = \"actor_user_name\", target = \"user.name\"}\n        },\n        [\"application.lifecycle.update\"] = {\n            {source = \"actor.id\", target = \"actor.user.uid\"},\n            {source = \"actor.type\", target = \"actor.user.type\"},\n            {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n            {source = \"actor.displayName\", target = \"actor.user.name\"},\n            {source = \"outcome.result\", target = \"status\"},\n            {source = \"outcome.reason\", target = \"status_detail\"},\n            {source = \"published\", target = \"metadata.original_time\"},\n            {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n            {source = \"transaction.detail\", target = \"raw_data\"},\n            {source = \"uuid\", target = \"metadata.uid\"},\n            -- target fields\n            {source = \"dst_endpoint_uid\", target = \"dst_endpoint.uid\"},\n            {source = \"dst_endpoint_svc_name\", target = \"dst_endpoint.svc_name\"},\n\n            --{source = \"actor_user_uid\", target = \"actor.user.uid\"},\n            {source = \"actor_email_addr\", target = \"actor.email_addr\"}\n            --{source = \"actor_user_name\", target = \"user.name\"}\n        }\n    }\n\n    return defaultMapping[eventType] or getGenericOktaMapping()\nend\n\n-- Generic Okta mapping\nfunction getGenericOktaMapping()\n    return {\n        {source = \"actor.id\", target = \"actor.user.uid\"},\n        {source = \"actor.alternateId\", target = \"actor.user.email_addr\"},\n        {source = \"actor.displayName\", target = \"actor.user.name\"},\n        {source = \"outcome.result\", target = \"status\"},\n        {source = \"outcome.reason\", target = \"status_detail\"},\n        {source = \"published\", target = \"metadata.original_time\"},\n        {source = \"transaction.id\", target = \"metadata.correlation_uid\"},\n        {source = \"transaction.detail\", target = \"raw_data\"},\n        {source = \"uuid\", target = \"metadata.uid\"}\n    }\nend\n\n-- Common mapping\nfunction getCommonMapping()\n    return {\n        {source = \"category_name\", target = \"category_name\"},\n        {source = \"category_uid\", target = \"category_uid\"},\n        {source = \"class_uid\", target = \"class_uid\"},\n        {source = \"severity_id\", target = \"severity_id\"},\n        {source = \"activity_name\", target = \"activity_name\"},\n        {source = \"activity_id\", target = \"activity_id\"},\n        {source = \"type_uid\", target = \"type_uid\"},\n        {source = \"vendor_name\", target = \"metadata.product.vendor_name\"},\n        {source = \"name\", target = \"metadata.product.name\"},\n        {source = \"OCSF_version\", target = \"metadata.version\"},\n        {source = \"time\", target = \"time\"},\n        {source = \"status_id\", target = \"status_id\"},\n        {source = \"type_id\", target = \"actor.user.type_id\"},\n        {source = \"observables\", target = \"observables\"},\n        {source = \"dataSource.category\", target = \"dataSource.category\"},\n        {source = \"site.id\", target = \"site.id\"},\n        {source = \"dataSource.name\", target = \"dataSource.name\"},\n        {source = \"dataSource.vendor\", target = \"dataSource.vendor\"},\n        {source = \"message\", target = \"message\"},\n        {source = \"class_name\", target = \"class_name\"},\n        {source = \"type_name\", target = \"type_name\"}\n    }\nend\n\n-- Parse security domain\nfunction parseSecurityDomain(parsedLog)\n    if parsedLog[\"src_endpoint.location.domain\"] == \".\" then\n        parsedLog[\"src_endpoint.location.domain\"] = nil\n    end\n    return parsedLog\nend\n\n-- Set site ID\nfunction setSiteId(oktaLog, siteId)\n    oktaLog[\"site\"] = {id = siteId}\n    return oktaLog\nend\n\n-- Parse risk level\nfunction parseRiskLevel(parsedLog)\n    local riskLevelMapper = {\n        [\"Info\"] = 0, [\"Low\"] = 1, [\"Medium\"] = 2,\n        [\"High\"] = 3, [\"Critical\"] = 4\n    }\n    local riskPrefix = \"level=\"\n    local finalRiskLevel = \"Other\"\n    local finalRiskLevelId = 99\n\n    -- Look for risk level in the already-mapped device.risk_level field\n    local riskLevel = \"\"\n    if parsedLog[\"device\"] and parsedLog[\"device\"][\"risk_level\"] then\n        riskLevel = parsedLog[\"device\"][\"risk_level\"]\n    end\n    \n    for riskLevelName, riskLevelId in pairs(riskLevelMapper) do\n        if string.find(string.lower(riskLevel), string.lower(riskPrefix .. riskLevelName)) then\n            finalRiskLevel = riskLevelName\n            finalRiskLevelId = riskLevelId\n            break\n        end\n    end\n\n    -- Set the parsed risk level back to the device object\n    if not parsedLog[\"device\"] then parsedLog[\"device\"] = {} end\n    parsedLog[\"device\"][\"risk_level\"] = finalRiskLevel\n    parsedLog[\"device\"][\"risk_level_id\"] = finalRiskLevelId\n    return parsedLog\nend\n\n-- Find event type\nfunction findEventType(log)\n    local eventType = log[\"eventType\"]\n    if eventType == nil then\n        return \"unknown\"\n    end\n    return eventType\nend\n\n-- Get category UID\nfunction getCategoryUID(eventType)\n    local categoryMapping = {\n        [\"user.session.start\"] = 3,\n        [\"user.authentication.sso\"] = 3,\n        [\"user.lifecycle.activate\"] = 2,\n        [\"user.lifecycle.create\"] = 3,\n        [\"user.lifecycle.deactivate\"] = 3,\n        [\"policy.evaluate_sign_on\"] = 3,\n        [\"system.org.rate_limit.warning\"] = 3,\n        [\"application.user_membership.add\"] = 3,\n        [\"application.lifecycle.update\"] = 6\n    }\n    return categoryMapping[eventType] or 0\nend\n\n-- Get class mapping\nfunction getClassMapping(eventType)\n    local classMapping = {\n        [\"user.session.start\"] = {name = \"Authentication\", id = 3002},\n        [\"user.authentication.sso\"] = {name = \"Authentication\", id = 3002},\n        [\"user.lifecycle.activate\"] = {name = \"Account Change\", id = 3001},\n        [\"user.lifecycle.create\"] = {name = \"Account Change\", id = 3001},\n        [\"user.lifecycle.deactivate\"] = {name = \"Account Change\", id = 3001},\n        [\"policy.evaluate_sign_on\"] = {name = \"Authentication\", id = 3002},\n        [\"system.org.rate_limit.warning\"] = {name = \"API Activity\", id = 6003},\n        [\"application.user_membership.add\"] = {name = \"Account Change\", id = 3001},\n        [\"application.lifecycle.update\"] = {name = \"Application Lifecycle\", id = 6002}\n    }\n    local mapping = classMapping[eventType] or {name = \"Base Event\", id = 0}\n    return mapping.name, mapping.id\nend\n\n-- Get status default OCSF mapping\nfunction getStatusDefaultOCSFMapping(status)\n    if status == nil then\n        return 0\n    end\n\n    local statusMapping = {\n        [\"SUCCESS\"] = 1,\n        [\"FAILURE\"] = 2\n    }\n    return statusMapping[status] or 99\nend\n\n-- Get activity name\nfunction getActivityName(eventType, eventTypeDisplayName)\n    local activityMapping = {\n        [\"user.session.start\"] = {name = \"Logon\", id = 1},\n        [\"user.authentication.sso\"] = {name = \"Logon\", id = 1},\n        [\"user.lifecycle.activate\"] = {name = \"Enable\", id = 2},\n        [\"user.lifecycle.create\"] = {name = \"Create\", id = 1},\n        [\"user.lifecycle.deactivate\"] = {name = \"Disable\", id = 5},\n        [\"policy.evaluate_sign_on\"] = {name = \"Logon\", id = 1},\n        [\"application.user_membership.add\"] = {name = \"Attach Policy\", id = 7}\n    }\n    local mapping = activityMapping[eventType] or {name = eventTypeDisplayName, id = 99}\n    return mapping.name, mapping.id\nend\n\n-- Get user type\nfunction getUserType(oktaUserType)\n    local userTypeMapping = {\n        [\"Unknown\"] = 0,\n        [\"User\"] = 1,\n        [\"Admin\"] = 2,\n        [\"System\"] = 3,\n        [\"Other\"] = 99\n    }\n    for user, id in pairs(userTypeMapping) do\n        if string.find(oktaUserType or \"\", user) then\n            return id\n        end\n    end\n    return 99\nend\n\n-- Get category mapper\nfunction getCategoryMapper(eventType)\n    local categoryMapper = {\n        [\"user.session.start\"] = \"Identity & Access Management\",\n        [\"user.authentication.sso\"] = \"Identity & Access Management\",\n        [\"user.lifecycle.activate\"] = \"Identity & Access Management\",\n        [\"user.lifecycle.create\"] = \"Identity & Access Management\",\n        [\"user.lifecycle.deactivate\"] = \"Identity & Access Management\",\n        [\"policy.evaluate_sign_on\"] = \"Identity & Access Management\",\n        [\"system.org.rate_limit.warning\"] = \"Application Activity\",\n        [\"application.user_membership.add\"] = \"Identity & Access Management\",\n        [\"application.lifecycle.update\"] = \"Application Activity\"\n    }\n    return categoryMapper[eventType] or \"Uncategorized\"\nend\n\n-- Get type name\nfunction getTypeName(eventType)\n    local typeMapper = {\n        [\"user.session.start\"] = \"Authentication: Logon\",\n        [\"user.authentication.sso\"] = \"Authentication: Logon\",\n        [\"user.lifecycle.activate\"] = \"Account Change: Enable\",\n        [\"user.lifecycle.create\"] = \"Account Change: Create\",\n        [\"user.lifecycle.deactivate\"] = \"Account Change: Disable\",\n        [\"policy.evaluate_sign_on\"] = \"Authentication: Logon\",\n        [\"system.org.rate_limit.warning\"] = \"API Activity: Other\",\n        [\"application.user_membership.add\"] = \"Account Change: Attach Policy\",\n        [\"application.lifecycle.update\"] = \"Application Lifecycle: Other\"\n    }\n    return typeMapper[eventType] or \"Base Event: Other\"\nend\n\n-- Get observables\nfunction getObservables(log)\n    local observables = {}\n\n    -- Hostname observable\n    local hostname = safelyAccessNestedDictKeys({\"debugContext\", \"debugData\", \"origin\"}, log)\n    if hostname and hostname ~= \"\" and hostname ~= \"null\" then\n        table.insert(observables, {\n            type_id = 1,\n            type = \"Hostname\",\n            name = \"device.hostname\",\n            value = hostname\n        })\n    end\n\n    -- IP Address observable\n    local clientIpAddress = safelyAccessNestedDictKeys({\"client\", \"ipAddress\"}, log)\n    if clientIpAddress and clientIpAddress ~= \"\" and clientIpAddress ~= \"null\" then\n        table.insert(observables, {\n            type_id = 2,\n            type = \"IP Address\",\n            name = \"src_endpoint.ip\",\n            value = clientIpAddress\n        })\n    end\n\n    -- User Name observable\n    local userName = safelyAccessNestedDictKeys({\"actor\", \"displayName\"}, log)\n    if userName and userName ~= \"\" and userName ~= \"null\" then\n        table.insert(observables, {\n            type_id = 4,\n            type = \"User Name\",\n            name = \"actor.user.name\",\n            value = userName\n        })\n    end\n\n    -- Email Address observable\n    local emailAddress = safelyAccessNestedDictKeys({\"actor\", \"alternateId\"}, log)\n    if emailAddress and emailAddress ~= \"\" and emailAddress ~= \"null\" then\n        table.insert(observables, {\n            type_id = 5,\n            type = \"Email Address\",\n            name = \"actor.user.email_addr\",\n            value = emailAddress\n        })\n    end\n\n    -- URL String observable\n    local requestUri = safelyAccessNestedDictKeys({\"debugContext\", \"debugData\", \"requestUri\"}, log)\n    if requestUri and requestUri ~= \"\" and requestUri ~= \"null\" then\n        table.insert(observables, {\n            type_id = 6,\n            type = \"URL String\",\n            name = \"http_request.url.path\",\n            value = requestUri\n        })\n    end\n\n    -- Geo Location observable\n    local lat = safelyAccessNestedDictKeys({\"client\", \"geographicalContext\", \"geolocation\", \"lat\"}, log)\n    local lon = safelyAccessNestedDictKeys({\"client\", \"geographicalContext\", \"geolocation\", \"lon\"}, log)\n    local notAllowedItems = {{}, {}, \"\", nil}\n    local latAllowed = true\n    local lonAllowed = true\n    for _, item in ipairs(notAllowedItems) do\n        if lat == item then latAllowed = false end\n        if lon == item then lonAllowed = false end\n    end\n    if latAllowed and lonAllowed and lat and lon then\n        table.insert(observables, {\n            type_id = 26,\n            type = \"Geo Location\",\n            name = \"client.geographicalContext.geolocation\",\n            value = lat .. \", \" .. lon\n        })\n    end\n\n    return observables\nend\n\n-- Process target fields into flat keys for mapping\nfunction processTargetFields(log, eventType)\n    local targetFields = {}\n    \n    if eventType == \"user.authentication.sso\" or\n            eventType == \"application.user_membership.add\" or\n            eventType == \"application.lifecycle.update\" then\n        local target = log[\"target\"]\n        if target and type(target) == \"table\" then\n            for _, t in ipairs(target) do\n                if type(t) == \"table\" then\n                    if t[\"type\"] == \"AppInstance\" then\n                        log[\"dst_endpoint_uid\"] = t[\"type\"]\n                        log[\"dst_endpoint_svc_name\"] = t[\"displayName\"]\n                    elseif t[\"type\"] == \"AppUser\" then\n                        -- Override specific fields with target values\n                        log[\"actor_user_uid\"] = t[\"type\"]  -- \"AppUser\" overrides actor.id\n                        log[\"actor_email_addr\"] = t[\"alternateId\"]  -- \"unknown\" for actor.email_addr\n                        log[\"actor_user_name\"] = t[\"displayName\"]  -- \"John Cena\" (same as original)\n                        \n                        -- Override actor.id for actor.user.uid mapping\n                        if log[\"actor\"] then\n                            log[\"actor\"][\"id\"] = t[\"type\"]  -- \"AppUser\" for actor.user.uid\n                            -- Keep actor.alternateId as original for actor.user.email_addr mapping\n                            -- Don't override actor.alternateId - let it stay as \"john.cena@wwe.com\"\n                        end\n                    end\n                end\n            end\n        end\n    elseif eventType == \"user.lifecycle.activate\" or\n            eventType == \"user.lifecycle.create\" or\n            eventType == \"user.lifecycle.deactivate\" then\n        local target = log[\"target\"]\n        if target and type(target) == \"table\" and #target > 0 then\n            local t = target[1]\n            if type(t) == \"table\" then\n                targetFields[\"user_id\"] = t[\"id\"]\n                targetFields[\"user_email_addr\"] = t[\"alternateId\"]\n                targetFields[\"user_name\"] = t[\"displayName\"]\n            end\n        end\n    elseif eventType == \"policy.evaluate_sign_on\" then\n        local target = log[\"target\"]\n        if target and type(target) == \"table\" then\n            for _, t in ipairs(target) do\n                if type(t) == \"table\" then\n                    if t[\"type\"] == \"PolicyEntity\" then\n                        targetFields[\"actor\"] = {\n                            authorization = {\n                                policy = {\n                                    name = t[\"displayName\"],\n                                    uid = t[\"id\"]\n                                }\n                            }\n                        }\n                    elseif t[\"type\"] == \"PolicyRule\" then\n                        targetFields[\"actor\"] = {\n                            authorization = {\n                                policy = {\n                                    rule = {\n                                        uid = t[\"id\"],\n                                        name = t[\"displayName\"]\n                                    }\n                                }\n                            }\n                        }\n                    end\n                end\n            end\n        end\n    end\n\n    return targetFields\nend\n\n-- Generate severity mapping\nfunction generateSeverityMapping(availableSeverityList)\n    local defaultSeverityMapping = {\n        [\"DEBUG\"] = 0, [\"INFO\"] = 1, [\"WARN\"] = 3, [\"ERROR\"] = 5, [\"OTHER\"] = 99\n    }\n    local defaultSeverityMappingKeys = {\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"OTHER\"}\n    local severityIDMapping = {}\n\n    for severityTypeIndex = 1, #availableSeverityList do\n        if availableSeverityList[severityTypeIndex] then\n            local key = defaultSeverityMappingKeys[severityTypeIndex]\n            severityIDMapping[key] = defaultSeverityMapping[key]\n        end\n    end\n    return severityIDMapping\nend\n\n-- Get severity ID\nfunction getSeverityID(eventType, logSeverity)\n    local severityMapping = {\n        [\"user.session.start\"] = generateSeverityMapping({true, true, true, true, true}),\n        [\"user.authentication.sso\"] = generateSeverityMapping({true, true, true, false, false}),\n        [\"user.lifecycle.activate\"] = generateSeverityMapping({true, true, true, false, false}),\n        [\"user.lifecycle.create\"] = generateSeverityMapping({false, true, false, false, false}),\n        [\"user.lifecycle.deactivate\"] = generateSeverityMapping({false, true, false, false, false}),\n        [\"policy.evaluate_sign_on\"] = generateSeverityMapping({false, true, false, false, false}),\n        [\"system.org.rate_limit.warning\"] = generateSeverityMapping({true, true, true, false, false}),\n        [\"application.user_membership.add\"] = generateSeverityMapping({true, true, true, false, false}),\n        [\"application.lifecycle.update\"] = generateSeverityMapping({false, true, false, false, false})\n    }\n    local eventSeverityMapping = severityMapping[eventType] or {}\n    return eventSeverityMapping[logSeverity] or 99\nend\n\n-- Generate synthetic fields\nfunction generateSyntheticFields(log, eventType, originalLog)\n    -- Set nested metadata fields\n    if not log[\"metadata\"] then log[\"metadata\"] = {} end\n    if not log[\"metadata\"][\"product\"] then log[\"metadata\"][\"product\"] = {} end\n    log[\"metadata\"][\"product\"][\"vendor_name\"] = \"Okta\"\n    log[\"metadata\"][\"product\"][\"name\"] = \"Okta\"\n    log[\"metadata\"][\"version\"] = \"1.0.0\"\n\n    local publishedTime = safelyAccessNestedDictKeys({\"published\"}, originalLog)\n    if publishedTime then\n        log[\"time\"] = convertToMilliseconds(publishedTime)\n    end\n\n    -- Use the event type passed as parameter instead of finding it again\n    log[\"category_name\"] = getCategoryMapper(eventType)\n    log[\"category_uid\"] = getCategoryUID(eventType)\n\n    local className, classUid = getClassMapping(eventType)\n    log[\"class_name\"] = className\n    log[\"class_uid\"] = classUid\n\n    -- Dynamic severity calculation\n    log[\"severity_id\"] = getSeverityID(eventType, originalLog[\"severity\"])\n\n    local activityName, activityId = getActivityName(eventType, originalLog[\"displayMessage\"] or \"Other\")\n    log[\"activity_name\"] = activityName\n    log[\"activity_id\"] = activityId\n\n    log[\"type_uid\"] = (classUid * 100) + activityId\n    log[\"type_name\"] = getTypeName(eventType)\n\n    local outcomeResult = safelyAccessNestedDictKeys({\"outcome\", \"result\"}, originalLog)\n    log[\"status_id\"] = getStatusDefaultOCSFMapping(outcomeResult)\n\n    local actorType = safelyAccessNestedDictKeys({\"actor\", \"type\"}, originalLog)\n\n\tif not log[\"actor\"] then log[\"actor\"] = {} end\n\tif not log[\"actor\"][\"user\"] then log[\"actor\"][\"user\"] = {} end\n\tlog[\"actor\"][\"user\"][\"type_id\"] = getUserType(actorType)\n\tlog[\"actor\"][\"user\"][\"type\"] = actorType or \"User\"\n    -- Actor email_addr is now set by target field mappings, don't override\n\n    -- Handle postal code conversion to string\n    local postalCode = safelyAccessNestedDictKeys({\"client\", \"geographicalContext\", \"postalCode\"}, log)\n    if postalCode then\n        if not log[\"client\"] then log[\"client\"] = {} end\n        if not log[\"client\"][\"geographicalContext\"] then log[\"client\"][\"geographicalContext\"] = {} end\n        log[\"client\"][\"geographicalContext\"][\"postalCode\"] = tostring(postalCode)\n    end\n\n    -- Target fields are now processed earlier in oktaLogsMapping\n\n\n    log[\"event.type\"] = log[\"activity_name\"] or eventType\n    log[\"dataSource\"] = {name = \"Okta\", category = \"security\", vendor = \"Okta\"}\n    \n    -- Add session field (skip root session for lifecycle events except deactivate)\n    local sessionId = safelyAccessNestedDictKeys({\"authenticationContext\", \"externalSessionId\"}, originalLog)\n    if not (eventType == \"user.lifecycle.activate\" or eventType == \"user.lifecycle.create\") then\n        if eventType == \"user.lifecycle.deactivate\" then\n            -- For deactivate events, add session to existing actor object if it exists\n            if log[\"actor\"] then\n                log[\"actor\"][\"session\"] = {uid = sessionId or \"unknown\"}\n            else\n                log[\"session\"] = {uid = sessionId or \"unknown\"}\n            end\n        end\n    end\n    \n    -- Add user field from actor only for non-lifecycle events\n    --local userName = safelyAccessNestedDictKeys({\"actor\", \"displayName\"}, originalLog)\n    --if userName and not (eventType == \"user.lifecycle.activate\" or eventType == \"user.lifecycle.create\" or eventType == \"user.lifecycle.deactivate\" or eventType == \"user.session.start\") then\n    --    log[\"user\"] = {name = userName}\n    --end\n\n    return log\nend\n\n\n-- Helper function to check if a field should be ignored\nfunction shouldIgnoreField(fieldName)\n\n    local ignoreFields = {\n        \"_okta_event_type\", \"_ob\", \"ts\", \"timestamp\"\n    }\n\n    for _, field in ipairs(ignoreFields) do\n        if fieldName == field or string.find(fieldName, \"^\" .. field .. \"%.\") then\n            return true\n        end\n    end\n    return false\nend\n\n-- Helper function to check if a value is empty (empty object, array, or null)\nfunction isEmptyValue(value)\n    if value == nil or value == \"NULL_PLACEHOLDER\" then\n        return true\n    end\n    if type(value) == \"string\" and (value == \"\" or value == \"null\") then\n        return true\n    end\n    if type(value) == \"table\" then\n        -- Check if it's an empty table\n        if next(value) == nil then\n            return true\n        end\n        -- For unmapped fields, recursively check nested values to filter out empty nested objects\n        local hasNonEmptyValues = false\n        for k, v in pairs(value) do\n            if not isEmptyValue(v) then\n                hasNonEmptyValues = true\n                break\n            end\n        end\n        return not hasNonEmptyValues\n    end\n    return false\nend\n\n-- Helper function to add unmapped fields as a truly nested object (no dotted keys)\nfunction addUnmappedFields(sourceObj, targetObj, mappedFields, prefixParts)\n    prefixParts = prefixParts or {}\n    for key, value in pairs(sourceObj) do\n        -- Skip ignored fields\n        if shouldIgnoreField(key) then\n            goto continue\n        end\n\n        -- Build current dotted path for mapped check\n        local currentPathParts = {}\n        for i = 1, #prefixParts do currentPathParts[i] = prefixParts[i] end\n        table.insert(currentPathParts, key)\n        local currentPath = table.concat(currentPathParts, \".\")\n\n        -- Check if this exact path has been mapped\n        local isMapped = mappedFields[currentPath] or false\n\n        if not isMapped and value ~= nil then\n            if type(value) == \"table\" then\n                local nestedObj = {}\n                addUnmappedFields(value, nestedObj, mappedFields, currentPathParts)\n                \n                -- Check if ALL direct children were mapped\n                local allChildrenMapped = true\n                for childKey, childValue in pairs(value) do\n                    local childPath = currentPath .. \".\" .. childKey\n                    if not mappedFields[childPath] then\n                        allChildrenMapped = false\n                        break\n                    end\n                end\n                \n                -- Only add parent if it has unmapped children OR no children were mapped\n                if next(nestedObj) and not allChildrenMapped then\n                    targetObj[key] = nestedObj\n                end\n                -- Don't add empty objects to unmapped\n            else\n                -- Only add non-empty values to unmapped\n                if not isEmptyValue(value) then\n                    targetObj[key] = value\n                end\n            end\n        end\n        ::continue::\n    end\nend\n\n-- Helper function to build nested object structure from flat dotted keys\nfunction buildNestedStructure(flatObj)\n    local nested = {}\n    for key, value in pairs(flatObj) do\n        local keys = split(key, \".\")\n        local current = nested\n        for i = 1, #keys - 1 do\n            local k = keys[i]\n            if not current[k] then\n                current[k] = {}\n            elseif type(current[k]) ~= \"table\" then\n                -- If the existing value is not a table, we can't create nested structure\n                -- Skip this key to avoid conflicts\n                goto continue\n            end\n            current = current[k]\n        end\n        \n        -- Special handling for raw_data field - encode as JSON string\n        if keys[#keys] == \"raw_data\" then\n            -- For raw_data, we want the value as a JSON string, not double-encoded\n            if type(value) == \"table\" then\n                current[keys[#keys]] = encodeJson(value, \"raw_data\")\n            else\n                -- If it's already a string, use it as-is\n                current[keys[#keys]] = tostring(value)\n            end\n        else\n            current[keys[#keys]] = value\n        end\n        ::continue::\n    end\n    return nested\nend\n\n-- Helper function to set nested value (marks field as processed)\nfunction setNestedValue(obj, keys, value)\n    local current = obj\n    for i = 1, #keys - 1 do\n        if not current[keys[i]] then\n            current[keys[i]] = {}\n        end\n        current = current[keys[i]]\n    end\n    current[keys[#keys]] = value\nend\n\n\n-- Helper function to filter out ignored fields using shouldIgnoreField\nfunction filterIgnoredFields(log)\n    local function filterObject(obj, prefix)\n        prefix = prefix or \"\"\n        local filteredObj = {}\n\n        for key, value in pairs(obj) do\n            local fullKey = prefix == \"\" and key or prefix .. \".\" .. key\n\n            if not shouldIgnoreField(fullKey) then\n                if type(value) == \"table\" then\n                    local filteredValue = filterObject(value, fullKey)\n                    if next(filteredValue) then  -- Only add non-empty tables\n                        filteredObj[key] = filteredValue\n                    end\n                else\n                    filteredObj[key] = value\n                end\n            end\n        end\n        return filteredObj\n    end\n\n    return filterObject(log)\nend\n\n\n-- Helper function to create ordered JSON message using FIELD_ORDER approach\nfunction createOrderedMessage(log, eventType)\n    -- Filter out null values and empty strings from the log before creating message\n    local filteredLog = {}\n    for k, v in pairs(log) do\n        if v ~= nil and v ~= \"\" and v ~= \"null\" then\n            if type(v) == \"table\" then\n                local filteredValue = filterNullValues(v)\n                if next(filteredValue) then  -- Only add non-empty tables\n                    filteredLog[k] = filteredValue\n                end\n            else\n                filteredLog[k] = v\n            end\n        end\n    end\n    \n    -- Apply domain filtering to the message for lifecycle events only\n    if eventType == \"user.lifecycle.create\" or eventType == \"user.lifecycle.deactivate\" or eventType == \"user.session.start\" then\n        filteredLog = applyDomainFiltering(filteredLog)\n    end\n    \n    -- Use FIELD_ORDERS.root to create ordered JSON string\n    local orderedJson = encodeWithFieldOrder(filteredLog, FIELD_ORDERS.root)\n    return orderedJson or \"{}\"\nend\n\n-- Helper function to recursively filter out null values from nested tables\nfunction filterNullValues(obj)\n    local filtered = {}\n    for k, v in pairs(obj) do\n        if v ~= nil and v ~= \"\" and v ~= \"null\" then\n            if type(v) == \"table\" then\n                local filteredValue = filterNullValues(v)\n                if next(filteredValue) then  -- Only add non-empty tables\n                    filtered[k] = filteredValue\n                end\n            else\n                filtered[k] = v\n            end\n        end\n    end\n    return filtered\nend\n\n-- Helper function to apply domain filtering recursively\nfunction applyDomainFiltering(obj)\n    if type(obj) ~= \"table\" then\n        return obj\n    end\n    \n    local filtered = {}\n    for k, v in pairs(obj) do\n        if type(v) == \"table\" then\n            local filteredValue = applyDomainFiltering(v)\n            if next(filteredValue) then  -- Only add non-empty tables\n                filtered[k] = filteredValue\n            end\n        else\n            -- Skip domain fields with value \".\" and isp fields that duplicate asOrg\n            if k == \"domain\" and v == \".\" then\n                -- Skip this field\n            elseif k == \"isp\" and obj[\"asOrg\"] and v == obj[\"asOrg\"] then\n                -- Skip isp field when it's the same as asOrg\n            else\n                filtered[k] = v\n            end\n        end\n    end\n    return filtered\nend\n\n-- Simplified Okta logs mapping function\nfunction oktaLogsMapping(log)\n    -- STEP 1: First filter out ignored fields using shouldIgnoreField\n    log = filterIgnoredFields(log)\n\n    -- STEP 2: Find event type first\n    local eventType = findEventType(log)\n    \n    -- STEP 3: Create ordered JSON message from original log BEFORE any modifications\n    local originalLog = {}\n    for k, v in pairs(log) do\n        originalLog[k] = v\n    end\n    log.message = createOrderedMessage(originalLog, eventType)\n\n    -- STEP 4: Process target fields to create flat keys for mapping\n    local targetFields = processTargetFields(log, eventType)\n    \n    -- Apply target fields to log for specific events so mappings can consume them\n    if eventType == \"policy.evaluate_sign_on\" then\n        for key, value in pairs(targetFields) do\n            if key == \"actor\" then\n                if not log[\"actor\"] then log[\"actor\"] = {} end\n                for subKey, subValue in pairs(value) do\n                    log[\"actor\"][subKey] = subValue\n                end\n            else\n                log[key] = value\n            end\n        end\n    elseif eventType == \"user.lifecycle.activate\" or eventType == \"user.lifecycle.create\" or eventType == \"user.lifecycle.deactivate\" then\n        -- For lifecycle events, expose target-derived user fields on the log\n        for key, value in pairs(targetFields) do\n            log[key] = value\n        end\n    end\n\n    -- STEP 4: Get mapping for event type\n    local mappings = getDefaultMapping(eventType)\n\n    -- Merge with common mapping\n    local commonMappings = getCommonMapping()\n    for _, mapping in ipairs(commonMappings) do\n        table.insert(mappings, mapping)\n    end\n\n    -- STEP 4: Apply mappings and track processed fields\n    local parsedData = {}\n    local mappedFields = {}\n    for _, mapping in ipairs(mappings) do\n        local sourcePath = mapping.source\n        local targetPath = mapping.target\n        local keys = split(sourcePath, \".\")\n        local value = safelyAccessNestedDictKeys(keys, log)\n\n        if value ~= nil and value ~= \"\" and value ~= \"null\" then\n            if targetPath == \"src_endpoint.location.domain\" and value == \".\" then\n                -- Skip this field for any event when domain is a single dot\n            else\n                -- Update target in parsedData\n                parsedData[targetPath] = value\n                -- Track mapped field by source path\n                mappedFields[sourcePath] = true\n            end\n        end\n    end\n\n    -- STEP 5: Add remaining non-null fields to unmapped\n    parsedData[\"unmapped\"] = {}\n    local ignoreUnmappedFields = {\n        \"actor_user_uid\",\n        \"actor_email_addr\", \n        \"actor_user_name\",\n        \"user_id\",\n        \"user_email_addr\",\n        \"user_name\"\n    }\n    for _, field in ipairs(ignoreUnmappedFields) do\n        mappedFields[field] = true\n    end\n\n    addUnmappedFields(log, parsedData[\"unmapped\"], mappedFields, {})\n    \n    -- Apply domain filtering to unmapped fields as well\n    parsedData[\"unmapped\"] = applyDomainFiltering(parsedData[\"unmapped\"])\n\n    -- STEP 6: Convert flat dotted keys to nested objects\n    parsedData = buildNestedStructure(parsedData)\n\n    -- STEP 7: Apply post-processing\n    parsedData = parseSecurityDomain(parsedData)\n    parsedData = parseRiskLevel(parsedData)\n\n    -- STEP 8: Generate synthetic fields\n    parsedData = generateSyntheticFields(parsedData, eventType, log)\n    \n    -- STEP 9: Generate observables for specific event types (after synthetic fields)\n    local observablesEventTypes = {\n        \"user.authentication.sso\",\n        \"application.user_membership.add\",\n        \"user.lifecycle.activate\",\n        \"user.lifecycle.create\",\n        \"user.lifecycle.deactivate\",\n        \"policy.evaluate_sign_on\",\n        \"system.org.rate_limit.warning\",\n        \"user.session.start\"\n    }\n\n    for _, eventTypeName in ipairs(observablesEventTypes) do\n        if eventType == eventTypeName then\n            local observables = getObservables(log)\n            -- Convert observables to array format\n            local observablesArray = {}\n            for _, obs in ipairs(observables) do\n                table.insert(observablesArray, obs)\n            end\n            parsedData[\"observables\"] = observablesArray\n            break\n        end\n    end\n    \n    parsedData = convertToNested(parsedData, eventType)\n    return parsedData\nend\n\n-- Convert flat parsed data to nested JSON structure with field ordering\nfunction convertToNested(parsedData, eventType)\n    local nested = {}\n    \n    -- First, build the nested structure\n    for key, value in pairs(parsedData) do\n        -- Special case: keep event.type as flattened field (don't nest it)\n        if key == \"event.type\" then\n            nested[\"event.type\"] = value  -- Keep as flattened event.type\n            goto continue\n        end\n        \n        local keys = split(key, \".\")\n        local current = nested\n        \n        -- Navigate to the parent object\n        for i = 1, #keys - 1 do\n            local k = keys[i]\n            if not current[k] then\n                current[k] = {}\n            elseif type(current[k]) ~= \"table\" then\n                -- If the existing value is not a table, we can't create nested structure\n                -- Skip this key to avoid conflicts\n                goto continue\n            end\n            current = current[k]\n        end\n        \n        -- Set the final value - special handling for raw_data field\n        if keys[#keys] == \"raw_data\" then\n            -- For raw_data, we want the value as a JSON string, not double-encoded\n            if type(value) == \"table\" then\n                current[keys[#keys]] = encodeJson(value, \"raw_data\")\n            else\n                -- If it's already a string, use it as-is\n                current[keys[#keys]] = tostring(value)\n            end\n        else\n            current[keys[#keys]] = value\n        end\n        ::continue::\n    end\n    \n    -- Then, apply field ordering to the nested structure\n    return applyFieldOrdering(nested, nil, eventType)\nend\n\n-- Apply field ordering to nested structure\nfunction applyFieldOrdering(obj, fieldOrder, eventType)\n    fieldOrder = fieldOrder or FIELD_ORDERS.root\n    local ordered = {}\n    \n    -- Phase 1: Add fields in predefined order\n    for _, fieldName in ipairs(fieldOrder) do\n        if obj[fieldName] ~= nil then\n            if type(obj[fieldName]) == \"table\" then\n                -- Recursively apply ordering to nested objects\n                local nestedFieldOrder = FIELD_ORDERS[fieldName]\n                ordered[fieldName] = applyFieldOrdering(obj[fieldName], nestedFieldOrder, eventType)\n            else\n                ordered[fieldName] = obj[fieldName]\n            end\n        end\n    end\n    \n    -- Phase 2: Add remaining fields not in the predefined order\n    for key, value in pairs(obj) do\n        local found = false\n        for _, fieldName in ipairs(fieldOrder) do\n            if key == fieldName then \n                found = true\n                break \n            end\n        end\n        \n        if not found then\n            if type(value) == \"table\" then\n                -- Recursively apply ordering to nested objects\n                local nestedFieldOrder = FIELD_ORDERS[key]\n                ordered[key] = applyFieldOrdering(value, nestedFieldOrder, eventType)\n            else\n                ordered[key] = value\n            end\n        end\n    end\n    \n    return ordered\nend\n\n-- Convert ISO 8601 timestamp to Unix epoch milliseconds\nfunction convertToMilliseconds(timestamp)\n  if not timestamp or timestamp == \"\" then\n    return nil\n  end\n  \n  -- Parse ISO 8601 format: \"2025-09-29T09:15:40Z\" or \"2025-09-29T09:15:40.123Z\"\n  local year, month, day, hour, min, sec, ms = string.match(timestamp, \"(%d+)%-(%d+)%-(%d+)T(%d+):(%d+):(%d+)%.?(%d*)Z\")\n  \n  if year and month and day and hour and min and sec then\n    local t = {\n      year = tonumber(year),\n      month = tonumber(month),\n      day = tonumber(day),\n      hour = tonumber(hour),\n      min = tonumber(min),\n      sec = tonumber(sec),\n      isdst = false\n    }\n    \n    -- Get local time interpretation\n    local local_seconds = os.time(t)\n    \n    -- Get what this represents in UTC\n    local utc_date = os.date(\"!*t\", local_seconds)\n    \n    local unix_seconds\n    -- Check if the UTC interpretation matches our input\n    if utc_date.year == tonumber(year) and utc_date.month == tonumber(month) and \n       utc_date.day == tonumber(day) and utc_date.hour == tonumber(hour) and \n       utc_date.min == tonumber(min) and utc_date.sec == tonumber(sec) then\n      -- We are already in UTC, use as-is\n      unix_seconds = local_seconds\n    else\n      -- Calculate the correct UTC timestamp\n      local utc_seconds = os.time(utc_date)\n      local offset = local_seconds - utc_seconds\n      unix_seconds = local_seconds + offset  -- Add offset to get UTC\n    end\n    \n    -- Add milliseconds if present\n    local milli = 0\n    if ms and ms ~= \"\" then\n      milli = tonumber((ms .. \"000\"):sub(1, 3))  -- pad/truncate to 3 digits\n    end\n    \n    return unix_seconds * 1000 + milli\n  end\n  \n  return nil\nend\n\n-- Main event processing function\nfunction processEvent(event)\n    return oktaLogsMapping(event)\nend",
                        "serializer": "okta-ocsf-1.0.0-schema"
                    }
                ]
            },
            "status": "NS_ACTIVE",
            "created": "2025-11-19T21:17:08.056377Z",
            "updated": "2025-11-19T21:17:08.056377Z",
            "createdBy": "",
            "updatedBy": "",
            "isTransformGroup": false,
            "origin": "NODE_ORIGIN_USER",
            "templateName": "OCSFSerializer",
            "processorType": "DATA_PROCESSOR",
            "siteFilenames": [],
            "userVisible": true
        }
    ],
    "archivalDestination": null
}
