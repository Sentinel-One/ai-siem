{"pipeline":{"id":"0","siteId":"16","name":"Pipeline Template_ProofPoint_Log","description":"","status":"DEFAULT","createdAt":"2025-11-21T00:09:25.383135Z","updatedAt":"2025-11-21T00:11:21.431785Z","deletedAt":null,"createdBy":"","updatedBy":"","deployedGraphVersion":0,"pendingGraphVersion":0,"latestGraphVersion":0,"sourceId":"0","pipelineType":"PIPELINE_TYPE_USER","pendingAction":"NOP","analytics":[]},"pipelineGraph":{"version":1,"pipelineId":"0","edges":{"100000000000000030":{"nodeIds":["300000000000000352"]},"300000000000000352":{"nodeIds":["200000000000000044"]}},"created":"2025-11-21T00:11:21.431785Z","createdBy":"","metaInfo":{"omissions":[{"omitted":{"100000000000000030":{"nodeIds":["300000000000000353"]},"300000000000000353":{"nodeIds":["300000000000000352"]}},"patch":{"100000000000000030":{"nodeIds":["300000000000000352"]}}},{"omitted":{"300000000000000352":{"nodeIds":["300000000000000354"]},"300000000000000354":{"nodeIds":["200000000000000044"]}},"patch":{"300000000000000352":{"nodeIds":["200000000000000044"]}}}]}},"source":{"id":"100000000000000030","siteId":"16","templateId":"35","templateVersion":"1","templateName":"Proofpoint SIEM API Collector","name":"Source Template_ProofPoint_Alerts","description":"This is the Default approach to Send data into your SentinelOne Console","config":{"auth.password":"********","auth.strategy":"basic","auth.user":"*****","config":{"PROOFPOINT_URL":"https://tap-api-v2.proofpoint.com/v2/siem/all"},"retry.backoff_scaling_factor":2,"retry.initial_backoff_secs":1,"retry.max_backoff_secs":5,"retry.max_retries":4,"scale.completion_queue":10,"scale.event_batch_queue":10,"scale.fetch_req_queue":1000,"scale.fetch_res_queue":10,"scale.fetchers":8,"scale.runtimes":2,"script":"function start(config)\n    -- Get the last checkpoint timestamp, or use a default if none exists\n    local since_time = get_chkpt(\"SINCE_TIME\")\n\n    fetch {\n        params = {\n            url = config[\"PROOFPOINT_URL\"],\n            query = {\n                format = \"json\",\n                sinceTime = since_time\n            },\n            method = \"GET\",\n            headers = {\n                [\"Accept\"] = \"application/json\"\n            }\n        },\n        fn = \"process_logs\",\n        retry = true, -- Enable retry for API calls\n        context = {\n            request_time = os.time(),\n            since_time_used = since_time\n        }\n    }\nend\n\nlocal json = require('json')\n\nfunction no_nulls(d, rn)\n    if type(d) == \"table\" then\n        for k, v in pairs(d) do\n            if type(v) == \"userdata\" and tostring(v) == \"userdata: (nil)\" then\n                d[k] = rn\n            elseif type(v) == \"table\" then\n                no_nulls(v, rn)\n            end\n        end\n    end\nend\n\nfunction process_logs(config, response, context)\n    if response.status == 200 then\n        bd = json.decode(response.body)\n        no_nulls(bd, nil)\n\n        -- Emit each individual event as a separate log\n        if bd and bd.messagesDelivered then\n            for _, event in ipairs(bd.messagesDelivered) do\n                event._proofpoint_event_type = \"messagesDelivered\"\n                event._proofpoint_query_end_time = bd.queryEndTime\n                emit{log = event}\n            end\n        end\n\n        if bd and bd.messagesBlocked then\n            for _, event in ipairs(bd.messagesBlocked) do\n                event._proofpoint_event_type = \"messagesBlocked\"\n                event._proofpoint_query_end_time = bd.queryEndTime\n                emit{log = event}\n            end\n        end\n\n        if bd and bd.clicksPermitted then\n            for _, event in ipairs(bd.clicksPermitted) do\n                event._proofpoint_event_type = \"clicksPermitted\"\n                event._proofpoint_query_end_time = bd.queryEndTime\n                emit{log = event}\n            end\n        end\n\n        if bd and bd.clicksBlocked then\n            for _, event in ipairs(bd.clicksBlocked) do\n                event._proofpoint_event_type = \"clicksBlocked\"\n                event._proofpoint_query_end_time = bd.queryEndTime\n                emit{log = event}\n            end\n        end\n\n        -- Handle pagination - check if there's a next page\n        if bd and bd.queryEndTime then\n            set_chkpt(\"SINCE_TIME\", bd.queryEndTime)\n        end\n\n    elseif response.status == 500 then\n        -- Server error - advance checkpoint slightly to avoid getting stuck\n        local current_utc = os.date('%Y-%m-%dT%H:%M:%SZ', os.time())\n        set_chkpt(\"SINCE_TIME\", current_utc)\n        emit{log = {\n            message = \"Proofpoint server error - advanced checkpoint to avoid getting stuck\",\n            status = response.status,\n            body = response.body,\n            original_since_time = context.since_time_used,\n            new_checkpoint = current_utc,\n            timestamp = context.request_time\n        }}\n\n    elseif response.status == 400 then\n        -- Bad request - update checkpoint to current UTC time\n        local current_utc = os.date('%Y-%m-%dT%H:%M:%SZ', os.time())\n        set_chkpt(\"SINCE_TIME\", current_utc)\n        emit{log = {\n            message = \"Bad request - updated checkpoint to current UTC time: \" .. current_utc,\n            status = response.status,\n            body = response.body,\n            new_checkpoint = current_utc\n        }}\n\n    elseif response.status == 401 then\n        emit{log = {\n            message = \"Authentication failed - check PROOFPOINT_TOKEN\",\n            status = response.status,\n            timestamp = context.request_time\n        }}\n    elseif response.status == 429 then\n        emit{log = {\n            message = \"Rate limit exceeded - will retry\",\n            status = response.status,\n            timestamp = context.request_time\n        }}\n    else\n        emit{log = {\n            message = \"Failed to fetch Proofpoint logs\",\n            status = response.status,\n            body = response.body,\n            timestamp = context.request_time\n        }}\n    end\nend","seed_checkpoints":{"SINCE_TIME":"2025-10-01T00:00:00Z"},"start_routine":"start","trigger.interval_secs":300},"status":"NS_ACTIVE","created":"2025-11-21T00:07:58.790520Z","updated":"2025-11-21T00:11:00.562298Z","createdBy":"","updatedBy":"","type":"SCOL","origin":"NODE_ORIGIN_USER","archivalInfo":null,"logFormat":"LOG_FORMAT_UNSPECIFIED","preprocessorConfig":null,"port":0,"pushBased":false,"pushSourceAddress":"","k8sInternalSvcUrl":"","siteFilenames":[],"sourceConfigs":[{"id":"0","sourceId":"0","templateId":"46","templateName":"SentimentAnalyzer","category":"PATTERN_EXTRACTOR","config":{"config_groups":[{"_name":"Config","enabled":false,"keyNameForExtractedSentiment":"sentiment","logLocations":[],"negativeSentimentRegexes":["time[\\s_-]*out","timed[\\s_-]*out","(?i)alert ([=\\s\\*]+|$)","(?i)bad[\\s_-]*gateway","(?i)bad[\\s_-]*request","(?i)(^| [=\\s\\*]+)bad([=\\s\\*]+|$)","(?i)does[\\s_-]*not[\\s_-]*exist","(?i)[=\\s\\*]+eof([=\\s\\*]+|$)","(?i)exception([=\\s\\*]+|$)","(?i)fail([=\\s\\*]+|$)","(?i)failed([=\\s\\*]+|$)","(?i)failure([=\\s\\*]+|$)","(?i)(^|[=\\s\\*]+)fault([=\\s\\*]+|$)","(?i)(^| [=\\s\\*]+)feof([=\\s\\*]+|$)","(?i)not[\\s_-]*acceptable","(?i)not[\\s_-]*allowed","(?i)not[\\s_-]*found","(?i)not[\\s_-]*ok","(?i)(^| [=\\s\\*]+)oom([=\\s\\*]+|$)","(?i)too[\\s_-]*many"],"negativeSentimentWords":["abnormal","abort","broken","canceled","caught","critical","denied","emergency","error","exception","fatal","incomplete","insufficient","interrupt","killed","killing","malformed","mismatch","outofmemory","panic","segfault","terminate","timeout","unable","unauthorized","undefined","unexpected","unprocessable","unstable","unhandled","unsuccessful","unusable","violation","rejection","rejected"],"useLogPath":true}]},"position":1,"templateVersion":"1"},{"id":"0","sourceId":"0","templateId":"71","templateName":"GeneratorVersion","category":"INTERNAL","config":{"generator_version":"v2"},"position":0,"templateVersion":"0"},{"id":"0","sourceId":"0","templateId":"65","templateName":"PatternExtractorPostProcessor","category":"PATTERN_EXTRACTOR","config":{"config_groups":[{"_name":"Pattern Extractor Configs","clusterTagNames":[],"truncate":false}]},"position":0,"templateVersion":"1"}],"userVisible":true,"usageType":"USER"},"destinations":[{"id":"200000000000000044","siteId":"16","templateId":"25","templateVersion":"0","templateName":"SentinelOne AI SIEM","name":"Sink Template_SentinelOne AI SIEM","description":"This is the Default approach to Send data into your SentinelOne Console","config":{"acknowledgements.enabled":false,"acknowledgements.indexer_acknowledgements_enabled":true,"acknowledgements.query_interval":10,"acknowledgements.retry_limit":30,"batch.timeout_secs":1,"compression":"none","default_token":"********","encoding.codec":"json","encoding.json.pretty":false,"encoding.metric_tag_values":"single","endpoint":"https://ingest.us1.sentinelone.net","endpoint_target":"event","host_key":"host","path":"/services/collector/event?isParsed=true","request.concurrency":"adaptive","request.headers":{},"request.rate_limit_duration_secs":1,"request.retry_initial_backoff_secs":1,"request.retry_max_duration_secs":3600,"request.timeout_secs":60,"timestamp_key":"timestamp","tls.verify_certificate":false,"tls.verify_hostname":false},"status":"NS_ACTIVE","sourceId":"0","created":"2025-11-16T22:17:36.683043Z","updated":"2025-11-20T17:19:18.696952Z","createdBy":"","updatedBy":"","type":"SPLUNK_HEC_LOGS","origin":"NODE_ORIGIN_USER","usageType":"USER","siteFilenames":[],"userVisible":true}],"transforms":[{"id":"300000000000000352","siteId":"16","templateId":"38","templateVersion":"1","name":"Transform Template_Proofpoint_Log_Transformer","description":"","pipelineId":"0","config":{"config_groups":[{"_name":"General Configuration","bypassed":false,"filterEnabled":false},{"_name":"ocsf","enabled":true,"parallelism":1,"script":"local FEATURES = {\n    FLATTEN_EVENT_TYPE = true,\n}\n-- Proofpoint to OCSF Mapping Script\nlocal OCSF_VERSION = \"v1.0.0-rc.3\"\n\n-- Click Event Mappings\nlocal clickEventMappings = {\n    -- OCSF structure fields (first)\n    {type=\"computed\", value=99, target=\"activity_id\"},\n    {type=\"computed\", value=\"Click\", target=\"activity_name\"},\n    {type=\"computed\", value=\"Network Activity\", target=\"category_name\"},\n    {type=\"computed\", value=4, target=\"category_uid\"},\n    {type=\"computed\", value=\"Email URL Activity\", target=\"class_name\"},\n    {type=\"computed\", value=4012, target=\"class_uid\"},\n    {type=\"computed\", value=\"Click\", target=\"event.type\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"metadata.product.name\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"metadata.product.vendor_name\"},\n    {type=\"computed\", value=\"1.0.0\", target=\"metadata.version\"},\n    {type=\"computed\", value=\"Click\", target=\"metadata.log_provider\"},\n    {type=\"computed\", value=\"security\", target=\"dataSource.category\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"dataSource.name\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"dataSource.vendor\"},\n    {type=\"computed\", value=3, target=\"severity_id\"},\n    {type=\"computed\", value=\"Email URL Activity: Other\", target=\"type_name\"},\n    {type=\"computed\", value=401299, target=\"type_uid\"},\n    \n    -- Direct field mappings\n    {type=\"direct\", source=\"clickIP\", target=\"device.ip\"},\n    {type=\"direct\", source=\"clickTime\", target=\"metadata.original_time\"},\n    {type=\"direct\", source=\"GUID\", target=\"email_uid\"},\n    {type=\"direct\", source=\"id\", target=\"metadata.uid\"},\n    {type=\"direct\", source=\"campaignID\", target=\"unmapped.campaignID\"},\n    {type=\"direct\", source=\"classification\", target=\"unmapped.classification\"},\n    {type=\"direct\", source=\"messageID\", target=\"unmapped.messageID\"},\n    {type=\"direct\", source=\"recipient\", target=\"unmapped.recipient\"},\n    {type=\"direct\", source=\"sender\", target=\"unmapped.sender\"},\n    {type=\"direct\", source=\"senderIP\", target=\"unmapped.senderIP\"},\n    {type=\"direct\", source=\"threatID\", target=\"unmapped.threatID\"},\n    {type=\"direct\", source=\"threatTime\", target=\"unmapped.threatTime\"},\n    {type=\"direct\", source=\"threatURL\", target=\"unmapped.threatURL\"},\n    {type=\"direct\", source=\"threatStatus\", target=\"unmapped.threatStatus\"},\n    {type=\"direct\", source=\"userAgent\", target=\"unmapped.userAgent\"},\n    \n    -- URL processing\n    {type=\"url_parse\", source=\"url\", targets={\"url.url_string\", \"url.hostname\", \"url.path\"}},\n    \n    -- Observables\n    {type=\"observable\", source=\"senderIP\", eventType=\"click\", type_id=2, observable_type=\"IP Address\", name=\"device.ip\"},\n    {type=\"observable\", source=\"recipient\", eventType=\"click\", type_id=5, observable_type=\"Email Address\", name=\"unmapped.recipient\"},\n    {type=\"observable\", source=\"sender\", eventType=\"click\", type_id=5, observable_type=\"Email Address\", name=\"unmapped.sender\"},\n    \n    -- Message field mappings (ordered to match expected output)\n    {type=\"message_field\", source=\"campaignID\", target=\"message.campaignID\"},\n    {type=\"message_field\", source=\"classification\", target=\"message.classification\"},\n    {type=\"message_field\", source=\"clickIP\", target=\"message.clickIP\"},\n    {type=\"message_field\", source=\"clickTime\", target=\"message.clickTime\"},\n    {type=\"message_field\", source=\"GUID\", target=\"message.GUID\"},\n    {type=\"message_field\", source=\"id\", target=\"message.id\"},\n    {type=\"message_field\", source=\"messageID\", target=\"message.messageID\"},\n    {type=\"message_field\", source=\"recipient\", target=\"message.recipient\"},\n    {type=\"message_field\", source=\"sender\", target=\"message.sender\"},\n    {type=\"message_field\", source=\"senderIP\", target=\"message.senderIP\"},\n    {type=\"message_field\", source=\"threatID\", target=\"message.threatID\"},\n    {type=\"message_field\", source=\"threatTime\", target=\"message.threatTime\"},\n    {type=\"message_field\", source=\"threatURL\", target=\"message.threatURL\"},\n    {type=\"message_field\", source=\"threatStatus\", target=\"message.threatStatus\"},\n    {type=\"message_field\", source=\"url\", target=\"message.url\"},\n    {type=\"message_field\", source=\"userAgent\", target=\"message.userAgent\"},\n    {type=\"message_field\", source=\"headerCC\", target=\"message.headerCC\"},\n    {type=\"message_field\", source=\"headerTo\", target=\"message.headerTo\"},\n    {type=\"message_field\", source=\"xmailer\", target=\"message.xmailer\"},\n    {type=\"message_field\", source=\"headerReplyTo\", target=\"message.headerReplyTo\"}\n}\n\n-- Message Event Mappings\nlocal messageEventMappings = {\n    -- OCSF structure fields (first)\n    {type=\"computed\", value=3, target=\"activity_id\"},\n    {type=\"computed\", value=\"Scan\", target=\"activity_name\"},\n    {type=\"computed\", value=\"Network Activity\", target=\"category_name\"},\n    {type=\"computed\", value=4, target=\"category_uid\"},\n    {type=\"computed\", value=\"Email Activity\", target=\"class_name\"},\n    {type=\"computed\", value=4009, target=\"class_uid\"},\n    {type=\"computed\", value=\"Scan\", target=\"event.type\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"metadata.product.name\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"metadata.product.vendor_name\"},\n    {type=\"computed\", value=\"1.0.0\", target=\"metadata.version\"},\n    {type=\"computed\", value=\"Scan\", target=\"metadata.log_provider\"},\n    {type=\"computed\", value=\"security\", target=\"dataSource.category\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"dataSource.name\"},\n    {type=\"computed\", value=\"Proofpoint\", target=\"dataSource.vendor\"},\n    {type=\"computed\", value=3, target=\"severity_id\"},\n    {type=\"computed\", value=\"Email Activity: Scan\", target=\"type_name\"},\n    {type=\"computed\", value=400903, target=\"type_uid\"},\n    {type=\"computed\", value=0, target=\"direction_id\"},\n    \n    -- Direct field mappings\n    {type=\"direct\", source=\"messageTime\", target=\"metadata.original_time\"},\n    {type=\"direct\", source=\"QID\", target=\"metadata.event_code\"},\n    {type=\"direct\", source=\"GUID\", target=\"metadata.uid\"},\n    {type=\"direct\", source=\"fromAddress\", target=\"email.from\"},\n    {type=\"direct\", source=\"messageID\", target=\"email.message_uid\"},\n    {type=\"direct\", source=\"fromAddress\", target=\"email.smtp_from\"},\n    {type=\"direct\", source=\"subject\", target=\"email.subject\"},\n    {type=\"direct\", source=\"senderIP\", target=\"src_endpoint.ip\"},\n    {type=\"direct\", source=\"spamScore\", target=\"unmapped.spamScore\"},\n    {type=\"direct\", source=\"phishScore\", target=\"unmapped.phishScore\"},\n    {type=\"direct\", source=\"threatsInfoMap\", target=\"unmapped.threatsInfoMap\"},\n    {type=\"direct\", source=\"impostorScore\", target=\"unmapped.impostorScore\"},\n    {type=\"direct\", source=\"malwareScore\", target=\"unmapped.malwareScore\"},\n    {type=\"direct\", source=\"cluster\", target=\"unmapped.clusterId\"},\n    {type=\"direct\", source=\"quarantineFolder\", target=\"unmapped.quarantineFolder\"},\n    {type=\"direct\", source=\"quarantineRule\", target=\"unmapped.quarantineRule\"},\n    {type=\"direct\", source=\"headerCC\", target=\"unmapped.headerCC\"},\n    {type=\"direct\", source=\"policyRoutes\", target=\"unmapped.policyRoutes\"},\n    {type=\"direct\", source=\"modulesRun\", target=\"unmapped.modulesRun\"},\n    {type=\"email_array\", source=\"toAddresses\", prefix=\"to\", target=\"email.smtp_to\"},\n    {type=\"direct\", source=\"messageParts\", target=\"unmapped.messageParts\"},\n    {type=\"direct\", source=\"completelyRewritten\", target=\"unmapped.completelyRewritten\"},\n    {type=\"direct\", source=\"sender\", target=\"unmapped.sender\"},\n    {type=\"direct\", source=\"recipient\", target=\"unmapped.recipient\"},\n    \n    -- Email processing\n    {type=\"email_array\", source=\"ccAddresses\", prefix=\"cc\", target=\"email.cc\"},\n    {type=\"email_array\", source=\"toAddresses\", prefix=\"to\", target=\"email.to\"},\n    \n    -- Observables\n    {type=\"observable\", source=\"senderIP\", eventType=\"message\", type_id=2, observable_type=\"IP Address\", name=\"src_endpoint.ip\"},\n    {type=\"observable\", source=\"recipient\", eventType=\"message\", type_id=5, observable_type=\"Email Address\", name=\"unmapped.recipient\"},\n    {type=\"observable\", source=\"sender\", eventType=\"message\", type_id=5, observable_type=\"Email Address\", name=\"unmapped.sender\"},\n    \n    -- Message field mappings\n    {type=\"message_field\", source=\"GUID\", target=\"message.GUID\"},\n    {type=\"message_field\", source=\"QID\", target=\"message.QID\"},\n    {type=\"message_field\", source=\"ccAddresses\", target=\"message.ccAddresses\"},\n    {type=\"message_field\", source=\"cluster\", target=\"message.clusterId\"},\n    {type=\"message_field\", source=\"completelyRewritten\", target=\"message.completelyRewritten\"},\n    {type=\"message_field\", source=\"fromAddress\", target=\"message.fromAddress\"},\n    {type=\"message_field\", source=\"headerCC\", target=\"message.headerCC\"},\n    {type=\"message_field\", source=\"headerFrom\", target=\"message.headerFrom\"},\n    {type=\"message_field\", source=\"headerReplyTo\", target=\"message.headerReplyTo\"},\n    {type=\"message_field\", source=\"headerTo\", target=\"message.headerTo\"},\n    {type=\"message_field\", source=\"impostorScore\", target=\"message.impostorScore\"},\n    {type=\"message_field\", source=\"malwareScore\", target=\"message.malwareScore\"},\n    {type=\"message_field\", source=\"messageID\", target=\"message.messageID\"},\n    {type=\"message_field\", source=\"messageParts\", target=\"message.messageParts\"},\n    {type=\"message_field\", source=\"messageTime\", target=\"message.messageTime\"},\n    {type=\"message_field\", source=\"modulesRun\", target=\"message.modulesRun\"},\n    {type=\"message_field\", source=\"phishScore\", target=\"message.phishScore\"},\n    {type=\"message_field\", source=\"policyRoutes\", target=\"message.policyRoutes\"},\n    {type=\"message_field\", source=\"quarantineFolder\", target=\"message.quarantineFolder\"},\n    {type=\"message_field\", source=\"quarantineRule\", target=\"message.quarantineRule\"},\n    {type=\"message_field\", source=\"recipient\", target=\"message.recipient\"},\n    {type=\"message_field\", source=\"replyToAddress\", target=\"message.replyToAddress\"},\n    {type=\"message_field\", source=\"sender\", target=\"message.sender\"},\n    {type=\"message_field\", source=\"senderIP\", target=\"message.senderIP\"},\n    {type=\"message_field\", source=\"spamScore\", target=\"message.spamScore\"},\n    {type=\"message_field\", source=\"subject\", target=\"message.subject\"},\n    {type=\"message_field\", source=\"threatsInfoMap\", target=\"message.threatsInfoMap\"},\n    {type=\"message_field\", source=\"toAddresses\", target=\"message.toAddresses\"}\n}\n\n-- Field ordering is now defined by the mapping order in fieldMappings table\n\nfunction getNestedField(obj, path)\n    if not obj or not path or path == '' then return nil end\n    local current = obj\n    for key in string.gmatch(path, '[^.]+') do\n        if not current or not key then return nil end\n        current = current[key]\n    end\n    return current\nend\n\nfunction setNestedField(obj, path, value)\n    if not path or path == '' then return end\n    local keys = {}\n    for key in string.gmatch(path, '[^.]+') do\n        table.insert(keys, key)\n    end\n    local current = obj\n    for i = 1, #keys - 1 do\n        if not current[keys[i]] then current[keys[i]] = {} end\n        current = current[keys[i]]\n    end\n    current[keys[#keys]] = value\nend\n\nfunction json_encode(obj, key)\n    if obj == nil then return \"null\" end\n    if type(obj) == \"boolean\" or type(obj) == \"number\" then return tostring(obj) end\n    if type(obj) == \"string\" then return '\"' .. obj:gsub('\"', '\\\\\"') .. '\"' end\n    if type(obj) == \"table\" then\n        local isArray = true\n        local maxIndex = 0\n        for k, v in pairs(obj) do\n            if type(k) ~= \"number\" then isArray = false; break end\n            maxIndex = math.max(maxIndex, k)\n        end\n        \n        if isArray then\n            if maxIndex > 0 then\n                local items = {}\n                for i = 1, maxIndex do\n                    if obj[i] ~= nil then\n                        table.insert(items, json_encode(obj[i], key))\n                    else\n                        table.insert(items, \"null\")\n                    end\n                end\n                return \"[\" .. table.concat(items, \", \") .. \"]\"\n            else\n                return \"[]\"\n            end\n        else\n            local items = {}\n            for k, v in pairs(obj) do\n                local keyStr = type(k) == \"string\" and k or tostring(k)\n                table.insert(items, '\"' .. keyStr:gsub('\"', '\\\\\"') .. '\": ' .. json_encode(v, keyStr))\n            end\n            return \"{\" .. table.concat(items, \", \") .. \"}\"\n        end\n    end\n    return '\"' .. tostring(obj) .. '\"'\nend\n\n-- Custom encoding function for message fields that includes null values\nfunction json_encode_message(obj, key)\n    if obj == nil then return \"null\" end\n    if type(obj) == \"boolean\" or type(obj) == \"number\" then return tostring(obj) end\n    if type(obj) == \"string\" then return '\"' .. obj:gsub('\"', '\\\\\"') .. '\"' end\n    if type(obj) == \"table\" then\n        local isArray = true\n        local maxIndex = 0\n        for k, v in pairs(obj) do\n            if type(k) ~= \"number\" then isArray = false; break end\n            maxIndex = math.max(maxIndex, k)\n        end\n        \n        if isArray or key == \"tags\" then\n            if maxIndex > 0 then\n                local items = {}\n                for i = 1, maxIndex do\n                    if obj[i] ~= nil then\n                        table.insert(items, json_encode_message(obj[i], key))\n                    else\n                        table.insert(items, \"null\")\n                    end\n                end\n                return \"[\" .. table.concat(items, \", \") .. \"]\"\n            else\n                return \"[]\"\n            end\n        else\n            local items = {}\n            for k, v in pairs(obj) do\n                local keyStr = type(k) == \"string\" and k or tostring(k)\n                table.insert(items, '\"' .. keyStr:gsub('\"', '\\\\\"') .. '\": ' .. json_encode_message(v, keyStr))\n            end\n            return \"{\" .. table.concat(items, \", \") .. \"}\"\n        end\n    end\n    return '\"' .. tostring(obj) .. '\"'\nend\n\n-- Field ordering maps based on mapping table structure\nlocal fieldOrderMaps = {\n    messageParts = {\n        \"contentType\", \"disposition\", \"filename\", \"md5\", \n        \"oContentType\", \"sandboxStatus\", \"sha256\"\n    },\n    threatsInfoMap = {\n        \"campaignID\", \"classification\", \"threat\", \"threatID\",\n        \"threatStatus\", \"threatTime\", \"threatType\", \"threatUrl\"\n    }\n}\n\n-- Helper function to encode objects with specific field order\nfunction encodeWithFieldOrder(obj, fieldOrder)\n    local items = {}\n    -- First, add fields in the specified order\n    for _, fieldName in ipairs(fieldOrder) do\n        if obj[fieldName] ~= nil then\n            local valueStr = json_encode_ordered(obj[fieldName], fieldName)\n            table.insert(items, '\"' .. fieldName .. '\": ' .. valueStr)\n        end\n    end\n    -- Then add any remaining fields not in the order list\n    for k, v in pairs(obj) do\n        local found = false\n        for _, fieldName in ipairs(fieldOrder) do\n            if k == fieldName then found = true; break end\n        end\n        if not found then\n            local valueStr = json_encode_ordered(v, k)\n            table.insert(items, '\"' .. k .. '\": ' .. valueStr)\n        end\n    end\n    return \"{\" .. table.concat(items, \", \") .. \"}\"\nend\n\n-- Ordered JSON encoding function that preserves field order\nfunction json_encode_ordered(obj, key)\n    if obj == nil then return \"null\" end\n    if type(obj) == \"boolean\" or type(obj) == \"number\" then return tostring(obj) end\n    if type(obj) == \"string\" then return '\"' .. obj:gsub('\"', '\\\\\"') .. '\"' end\n    if type(obj) == \"table\" then\n        local isArray = true\n        local maxIndex = 0\n        for k, v in pairs(obj) do\n            if type(k) ~= \"number\" then isArray = false; break end\n            maxIndex = math.max(maxIndex, k)\n        end\n        \n        if isArray then\n            if maxIndex > 0 then\n                local items = {}\n                for i = 1, maxIndex do\n                    if obj[i] ~= nil then\n                        table.insert(items, json_encode_ordered(obj[i], key))\n                    else\n                        table.insert(items, \"null\")\n                    end\n                end\n                return \"[\" .. table.concat(items, \", \") .. \"]\"\n            else\n                return \"[]\"\n            end\n        else\n            -- Use field order maps for known object types\n            if (key == \"messageParts\" or key:match(\"%.messageParts$\")) and fieldOrderMaps.messageParts then\n                return encodeWithFieldOrder(obj, fieldOrderMaps.messageParts)\n            elseif (key == \"threatsInfoMap\" or key:match(\"%.threatsInfoMap$\")) and fieldOrderMaps.threatsInfoMap then\n                return encodeWithFieldOrder(obj, fieldOrderMaps.threatsInfoMap)\n            else\n                -- Use existing logic for other objects\n                local items = {}\n                -- Use ipairs to preserve order for numeric keys, then pairs for string keys\n                local orderedKeys = {}\n                for k, v in pairs(obj) do\n                    if type(k) == \"number\" then\n                        table.insert(orderedKeys, {k, v, true})\n                    end\n                end\n                table.sort(orderedKeys, function(a, b) return a[1] < b[1] end)\n                \n                for k, v in pairs(obj) do\n                    if type(k) == \"string\" then\n                        table.insert(orderedKeys, {k, v, false})\n                    end\n                end\n                \n                for _, item in ipairs(orderedKeys) do\n                    local k, v, isNumeric = item[1], item[2], item[3]\n                    local keyStr = isNumeric and tostring(k) or '\"' .. k:gsub('\"', '\\\\\"') .. '\"'\n                    table.insert(items, keyStr .. ': ' .. json_encode_ordered(v, k))\n                end\n                return \"{\" .. table.concat(items, \", \") .. \"}\"\n            end\n        end\n    end\n    return '\"' .. tostring(obj) .. '\"'\nend\n\njson = { encode = json_encode }\n\nfunction processEvent(event)\n    if not event then return event end\n    if type(event) == \"table\" and event[1] then event = event[1] end\n    \n    local result = {}\n    local messageFields = {}\n    \n    -- Determine event type and get mappings\n    local eventType = \"message\"  -- default to message\n    if event._proofpoint_event_type == \"clicksBlocked\" or event._proofpoint_event_type == \"clicksPermitted\" then\n        eventType = \"click\"\n    elseif event._proofpoint_event_type == \"messagesBlocked\" or event._proofpoint_event_type == \"messagesDelivered\" then\n        eventType = \"message\"\n    else\n        -- Fallback to original logic\n        eventType = (event.clickIP or event.url or event.clickTime) and \"click\" or \"message\"\n    end\n    local mappings = eventType == \"click\" and clickEventMappings or messageEventMappings\n    \n    -- Apply mappings in order\n    for _, mapping in ipairs(mappings) do\n        local value = nil\n        \n        if mapping.type == \"computed\" then\n            value = mapping.value\n        elseif mapping.type == \"direct\" then\n            value = getNestedField(event, mapping.source)\n        elseif mapping.type == \"multi\" then\n            value = getNestedField(event, mapping.source)\n        elseif mapping.type == \"url_parse\" then\n            -- Handle URL parsing - create nested url object with url_string as JSON string\n            if event[mapping.source] then\n                local urlParts = parseUrl(event[mapping.source])\n                setNestedField(result, \"url.hostname\", urlParts.hostname)\n                setNestedField(result, \"url.path\", urlParts.path)\n                -- Create url_string as JSON string\n                local urlStringJson = '{\"path\":\"' .. urlParts.path:gsub('\"', '\\\\\"'):gsub('\\\\', '\\\\\\\\') .. '\",\"hostname\":\"' .. urlParts.hostname:gsub('\"', '\\\\\"'):gsub('\\\\', '\\\\\\\\') .. '\"}'\n                setNestedField(result, \"url.url_string\", urlStringJson)\n            end\n        elseif mapping.type == \"email_array\" then\n            -- Handle email arrays - create GRON format\n            if event[mapping.source] then\n                for i, email in ipairs(event[mapping.source]) do\n                    local fieldName = mapping.target .. \"[\" .. (i-1) .. \"]\"\n                    setNestedField(result, fieldName, email)\n                end\n            end\n        elseif mapping.type == \"email_convert\" then\n            -- Handle email conversion\n            if event[mapping.source] then\n                local emailValue = type(event[mapping.source]) == 'table' and event[mapping.source][1] or event[mapping.source]\n                setNestedField(result, mapping.target, emailValue)\n            end\n        elseif mapping.type == \"observable\" then\n            -- Handle observables (will be processed separately)\n        elseif mapping.type == \"message_field\" then\n            value = getNestedField(event, mapping.source)\n        end\n        \n        -- Set the value\n        if mapping.type == \"direct\" then\n            setNestedField(result, mapping.target, value)\n        elseif mapping.type == \"multi\" then\n            for _, target in ipairs(mapping.targets) do\n                setNestedField(result, target, value)\n            end\n        elseif mapping.type == \"computed\" then\n            setNestedField(result, mapping.target, value)\n        elseif mapping.type == \"message_field\" then\n            -- Handle message fields separately\n            local messageKey = mapping.target:gsub(\"message%.\", \"\")\n            -- Only include fields that exist in the input data\n            if value ~= nil then\n                messageFields[messageKey] = value\n            end\n        end\n    end\n    \n    -- Add metadata.log_name based on event type\n    if eventType == \"click\" then\n        if event._proofpoint_event_type == \"clicksPermitted\" then\n            setNestedField(result, \"metadata.log_name\", \"clicksPermitted\")\n        elseif event._proofpoint_event_type == \"clicksBlocked\" then\n            setNestedField(result, \"metadata.log_name\", \"clicksBlocked\")\n        end\n    else\n        if event._proofpoint_event_type == \"messagesDelivered\" then\n            setNestedField(result, \"metadata.log_name\", \"messagesDelivered\")\n        elseif event._proofpoint_event_type == \"messagesBlocked\" then\n            setNestedField(result, \"metadata.log_name\", \"messagesBlocked\")\n        end\n    end\n    \n    -- Process observables\n    local observables = buildObservablesFromMappings(event, eventType)\n    if #observables > 0 then \n        result.observables = observables\n    end\n    \n    -- Set timestamp - convert to nanoseconds\n    if eventType == \"click\" then\n        local timeStr = event.clickTime or os.date(\"!%Y-%m-%dT%H:%M:%S.000Z\")\n        if timeStr and timeStr ~= \"\" then\n            -- Convert ISO timestamp to Unix timestamp in nanoseconds\n            local year, month, day, hour, min, sec = timeStr:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+)\")\n            if year and month and day and hour and min and sec then\n                local timeTable = {\n                    year = tonumber(year),\n                    month = tonumber(month),\n                    day = tonumber(day),\n                    hour = tonumber(hour),\n                    min = tonumber(min),\n                    sec = tonumber(sec),\n                    isdst = false  -- Ensure UTC timezone\n                }\n                result.time = os.time(timeTable) * 1000  -- Convert to milliseconds\n            else\n                result.time = os.time() * 1000\n            end\n        else\n            result.time = os.time() * 1000\n        end\n    else\n        -- For message events, convert to Unix timestamp in nanoseconds\n        local timeStr = event.messageTime or os.date(\"!%Y-%m-%dT%H:%M:%S.000Z\")\n        if timeStr and timeStr ~= \"\" then\n            -- Convert ISO timestamp to Unix timestamp in nanoseconds\n            local year, month, day, hour, min, sec = timeStr:match(\"(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+)\")\n            if year and month and day and hour and min and sec then\n                local timeTable = {\n                    year = tonumber(year),\n                    month = tonumber(month),\n                    day = tonumber(day),\n                    hour = tonumber(hour),\n                    min = tonumber(min),\n                    sec = tonumber(sec),\n                    isdst = false  -- Ensure UTC timezone\n                }\n                result.time = os.time(timeTable) * 1000  -- Convert to milliseconds\n            else\n                result.time = os.time() * 1000\n            end\n        else\n            result.time = os.time() * 1000\n        end\n    end\n    \n    -- Add message field if it exists (convert to JSON string with proper ordering)\n    if next(messageFields) then\n        -- Build JSON string directly in the correct order\n        local jsonParts = {}\n        for _, mapping in ipairs(mappings) do\n            if mapping.type == \"message_field\" then\n                local messageKey = mapping.target:gsub(\"message%.\", \"\")\n                if messageFields[messageKey] ~= nil then\n                    local value = messageFields[messageKey]\n                    local valueStr = json_encode_ordered(value, messageKey)\n                    table.insert(jsonParts, '\"' .. messageKey .. '\": ' .. valueStr)\n                end\n            end\n        end\n        result[\"message\"] = \"{\" .. table.concat(jsonParts, \", \") .. \"}\"\n    end\n    if FEATURES.FLATTEN_EVENT_TYPE then\n        if result and result.event then\n            result['event.type'] = result.event.type\n        end\n    end\n    return result\nend\n\n-- Utility functions\nfunction parseUrl(url)\n    if not url or url == \"\" then return {hostname = \"\", path = \"\"} end\n    local protocol, hostname, path = url:match(\"^(%w+)://([^/]+)(.*)$\")\n    if not hostname then\n        hostname = url:match(\"^([^/]+)\")\n        path = \"\"\n    else\n        if path and path ~= \"\" and not path:match(\"^/\") then\n            path = \"/\" .. path\n        end\n    end\n    return {hostname = hostname or \"\", path = path or \"\"}\nend\n\n\nfunction buildObservablesFromMappings(event, eventType)\n    local observables = {}\n    \n    for _, mapping in ipairs(eventType == \"click\" and clickEventMappings or messageEventMappings) do\n        if mapping.type == \"observable\" then\n            local value = getNestedField(event, mapping.source)\n            if value then\n                local observableName = mapping.name\n                if eventType == \"click\" and mapping.source == \"senderIP\" then\n                    observableName = \"device.ip\"\n                elseif eventType == \"message\" and mapping.source == \"senderIP\" then\n                    observableName = \"src_endpoint.ip\"\n                end\n                \n                -- Convert email arrays to comma-separated strings for observables\n                local observableValue = value\n                if type(value) == \"table\" and mapping.observable_type == \"Email Address\" then\n                    local emailList = {}\n                    for _, email in ipairs(value) do\n                        table.insert(emailList, email)\n                    end\n                    observableValue = table.concat(emailList, \",\")\n                end\n                \n                table.insert(observables, {\n                    type_id = mapping.type_id,\n                    type = mapping.observable_type,\n                    name = observableName,\n                    value = observableValue\n                })\n            end\n        end\n    end\n    \n    return observables\nend\n\nfunction process(event, emit)\n    local out = processEvent(event[\"log\"])\n    if out ~= nil then\n        event[\"log\"] = out\n        emit(event)\n    end\nend","serializer":"proofpoint-lua"}]},"status":"NS_ACTIVE","created":"2025-11-21T00:09:25.795844Z","updated":"2025-11-21T00:09:25.795844Z","createdBy":"","updatedBy":"","isTransformGroup":false,"origin":"NODE_ORIGIN_USER","templateName":"OCSFSerializerExtended","processorType":"DATA_PROCESSOR","siteFilenames":[],"userVisible":true}],"archivalDestination":null}